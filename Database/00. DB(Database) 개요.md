## 데이터베이스
- 데이터베이스를 제어하고 관리하는 통합 시스템을 DBMS(DataBase Management System) 라고 한다
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어(query language)를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있다

### 1. 데이터베이스 용어
- 엔티티(entity)
  - 사람, 장소, 물건 등 여러 개의 속성을 지닌 명사를 의미한다
- 릴레이션(relation)
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/2c04e9c1-757b-4cd1-a7ad-98718e8ef5e0)
  - 데이터베이스에서 정보를 구분하여 저장하는 기본 단위이고, 데이터베이스는 릴레이션 하나에 엔티티에 관한 데이터를 담아서 관리한다
  - 관계형 데이터베이스에서는 테이블이라고 하며, NoSQL(No Structured Query Language) 데이터베이스에서는 컬렉션이라고 한다
- 속성(attribute)
  - 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보이다
  - 서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 정보만 엔티티의 속성으로 관리한다
- 도메인(domain)
  - 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 의미한다
- 필드(field)
  - 릴레이션에서 열(column)에 해당하는 가장 작은 단위의 데이터를 의미한다
  - 숫자 타입: TINYINT(1Byte), SMALLYINT(2Byte), MEDIUMYINT(3Byte), INT(4Byte), BIGINT(8Byte)
  - 날짜 타입: DATE(시간부분x), DATETIME(시간부분o, 8Byte), TIMESTAMP(시간부분o, 4Byte)
  - 문자 타입
    - CHAR(고정 길이 문자열): CHAR(100)으로 선언하면 10글자를 저장해도 100바이트로 저장된다
    - VARCHAR(가변 길이 문자열): VARCHAR(100)으로 선언한 후 10글자 문자열을 저장한다면 10글자Byte + 길이기록1Byte 만 저장된다
    - TEXT(큰 문자열 저장), BLOB(이미지, 동영상 등), ENUM(문자열 열거 타입)
- 레코드(record)
  - 릴레이션에서 행(row)에 해당하는 논리적으로 연관된 필드의 집합을 의미하고, 튜플(tuple)이라고 불리기도 한다
- 관계(relationship)
  - 관계를 나타내는 방법
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/d55a66c7-4322-4f07-8593-f997b7722f37)
  - 1:1 관계: 하나의 레코드가 다른 테이블 레코드 한 개와 연결된 경우, 자주 사용되지 않음(같은 테이블로 묶을 수 있음)
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/8c20723d-b314-40cf-af68-b25f2bcd1c3c)
  - 1:N 관계: 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/a0e519e2-3726-4d0d-93fb-5d4b49944159)
  - N:M 관계: 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 연결된 경우, 스키마를 디자인할 때 2개의 1:N 관계로 Join 테이블을 만들어 관리한다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/9370ed7a-1b74-47ef-90b7-294456dfc923)
- 키(key)
  - 테이블 간의 관계를 조금 더 명확하고 테이블 자체의 인덱스를 위해 설정된 장치
    - 유일성: 중복되는 값이 없다는 의미
    - 최소성: 필드를 조합하지 않고 최소 필드만을 사용한다는 의미 ({ID, name}과 같은 복합키는 안됨)
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/b3409ebb-6955-4c6e-ae82-f4dba7372565)
  - 기본키(primary key, PK): 테이블의 데이터 중 고유하게 존재하는 속성으로 유일성과 최소성을 만족하는 키, MySQL의 auto increment로 기본키를 만들어 사용할 수 있다
  - 외래키(foreign key, FK): 다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용한다
  - 후보키(candidate key): 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족하는 키
  - 대체키(alternate key): 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보들을 지칭한다
  - 슈퍼키(super key): 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

### 2. ERD와 정규화 과정
- ERD(Entity Relationship Diagram)
  - 개체-관계 모델로 릴레이션 간의 관계를 정의한 것으로, 데이터베이스를 구축할 때 가장 기초적인 뼈대로 사용한다
  - 요구 사항을 기반으로 ERD를 만드는 방법
    - ERD 예제 1
      - 영업 사원을 0~n명의 고객을 관리한다
      - 고객은 0~n개의 주문을 넣을 수 있다
      - 주문에는 1~n개의 상품이 들어간다
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/3199a7f2-468b-45a2-97c9-db3198931bdb)
    - ERD 예제 2
      - 선수들은 1명의 챔피언을 고를 수 있다
      - 챔피언은 한 개 이상의 스킬을 갖는다
      - 스킬은 한 개 이상의 특성을 갖는다
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/34755823-fcc5-492e-9fe7-cc457eed00f9)
- 정규화(Normalization) 과정
  - 릴레이션 간의 잘못된 종속 관계를 해결하거나 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정이다
  - 자료의 중복성을 줄이고, 독립적인 관계는 별개의 릴레이션으로 표현하며, 각각의 릴레이션은 독립적인 표현이 가능하게 만들어야 한다
  - 정규화된 정도는 정규형(NF, Normal Form)으로 표현한다
  - 제1정규형
    - 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 한다
    - 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안된다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/c016d765-abf6-4478-b7f8-a0c8558645e6)
  - 제2정규형
    - 릴레이션이 제1정규형이며 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적으로 만든다(부분 함수 종속 제거)
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/7cc90a47-7d2e-4a9d-9486-d0b571ccb77d)
  - 제3정규형
    - 제2정규형이며 기본키가 아닌 모든 속성이 이행적 함수 종속(transitive FD)을 만족하지 않게 만든다(이행 함수 종속 제거)
    - 이행적 함수 종속이란 A->B, B->C 의 종속이 존재하면 논리적으로 A->C가 성립하는데 이때 집합 C가 집합 A에 이행적으로 종속되었다고 말한다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/dd2aa1c8-5b4d-4593-a8d0-92a9426879a7)
  - 보이스/코드 정규형(BCNF)
    - 제3정규형이며 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태로 만든다(결정자가 후보키가 아닌 함수 종속 제거)
    - 결정자란 함수 종속 관계에서 특정 종속자(dependent)를 결정짓는 요소로 X->Y 의 종속에서 X는 결정자, Y는 종속자이다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/72f6f0e3-6c45-4ebd-8059-5a793ce8f7c2)

### 3. 트랙잭션과 무결성
- 트랜잭션(Transaction)
  - 트랜잭션이란 데이터베이스에서 여러 개의 쿼리들을 하나로 묶어 논리적 기능을 수행하기 위한 작업의 단위를 의미한다
    - 커밋(commit)은 여러 쿼리가 성공적으로 수행되어 하나의 트랜잭션이 성공적으로 수행되었다는 것을 의미한다
    - 롤백(rollback)은 에러나 이슈 때문에 트랜잭션 전으로 작업을 취소하는 것을 의미한다
  - 트랜잭션을 수행할 때는 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야 한다
  - 커넥션 객체를 일일이 넘기지 않고, 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다(Spring의 @Transactional 애너테이션)
  - 트랜잭션에 대한 특징으로 ACID 특징(원자성, 일관성, 격리성, 지속성)라고 한다
    - 원자성(Atomicity)
      - 트랜잭션과 관린된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다(all or nothing)
      - 트랜잭션 단위로 여러 로직을 묶을 때 외부 API를 호출하는 것이 있으면 롤백할 경우 해결 방법이 명확해야 된다
    - 일관성(Consistency)
      - 데이터에 대한 조건과 규칙에 따라 허용된 방식으로만 데이터를 변경해야 하는 것을 의미한다
    - 격리성(Isolation)
      - 트랜잭션 수행 시 서로 끼어들지 못하는 것을 의미하고, 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동해야 한다
      - 격리성은 여러 개의 격리 수준으로 나뉘어서 실행되고, 격리 수준에 따라 발생하는 현상이 존재한다
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/256209ec-d204-4a58-9287-13c4299974c3)
      - 격리 수준
        - SERIALIZABLE: 트랜잭션을 순차적으로 진행시켜, 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다
        - REPEATALBE_READ: 다른 트랜잭션이 시작되기 전에 커밋이 완료된 내용에 대해서만 조회할 수 있고, 새로운 행을 추가하는 것은 막지 않는다
        - READ_COMMITTED: 커밋이 완료된 데이터에 대해서만 조회를 허용하고 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없지만, 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다 
        - READ_UNCOMMITTED: 하나의 트랜잭션이 커밋되기 전에 다른 트랜잭션에 노출도 허용한다
      - 격리 수준에 따라 발생하는 현상
        - 팬텀 리드(phantom read)
          - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
          - A 트랜잭션에서 age 12 이상인 회원의 수를 조회한 후, B 트랜잭션이 age가 15인 회원 레코드를 삽입하면, A 트랜잭션에서 다시 조회했을 때 수가 달라지는 경우를 의미(추가 된 다른 행이 선택될 수도 있다)
          - REPEATABLE_READ 이하의 격리성 부터 발생할 수 있다
        - 반복 가능하지 않은 조회(non-repeatable read)
          - 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
          - A 트랜잭션에서 사용자 1의 age를 조회한 후, B 트랜잭션이 그 회원의 age를 15로 변경하면(커밋 후), A 트랜잭션(커밋 전)에서 다시 조회했을 때 값이 달라지는 경우를 의미
          - READ_COMMITTED 이하의 격리성 부터 발생할 수 있다
        - 더티 리드(dirty read)
          - 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있을 경우
          - A 트랜잭션에서사용자 1의 age를 조회한 후, B 트랜잭션의 그 회원의 age를 15로 변경하는 내용이 아직 커밋되지 않은 상태에서, A 트랜잭션에서 다시 조회했을 때 값이 달라지는 경우를 의미
          - READ_UNCOMMITTED 이하의 격리성 부터 발생할 수 있다
    - 지속성(Durability)
      - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다는 것을 의미하고, 데이터베이스 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함을 뜻한다
      - 데이터베이스는 이를 위해 체크섬(무결성을 보호가기 위한 방법), 저널링(커밋하기 전에 로깅하는 것), 롤백 등의 기능을 제공한다
      - 무결성이란 데이터의 정확성, 일관성, 유효성을 유지하는 것을 의미한다


### 4. 인덱스
- 인덱스(index)를 설정하면 테이블 안에 찾고자 하는 데이터를 빠르게 찾을 수 있고, 보통 B-Tree 자료 구조로 이루어져 있다
- 인덱스는 효율적인 단계를 거쳐 모든 오소에 접글할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성이 좋다
- 대수확장성이란 트리 깊이가 리프 노드 수에 비해 느리게 커진다는 의미로 트리 깊이에 따라 최대 인덱스 항목의 수가 4배씩 증가하고, 깊이가 10이면 100만개의 레코드를 검색할 수 있다
- B-Tree
  - HDD나 SSD와 같은 외부 기억장치는 블럭단위로 입출력을하는데 이때 발생하는 입출력 비용은 파일의 크기와 상관없이 동일하다
  - 1KB 블럭에 2byte과 1KB의 문자열의 입출력 비용은 같기 때문에 데이터베이스에서는 하나의 블럭에 여러 데이터들을 동시에 저장하기 위해서 이진트리 대신 B-Tree를 주로 사용한다
  - 이진트리를 확장한 트리로, 모든 리프 노트들이 같은 레벨에 존재하도록 밸런스를 맞추며, 하나의 노드여 여러 개의 데이터(key)를 저장할 수 있게 하였다
  - B-Tree의 조건
    1. 노드에는 2개 이상의 데이터(key)가 들어갈 수 있으며, 항상 정렬된 상태로 저장된다
    2. 특정 노드의 key가 K개 라면, 그 노드의 자식 노드의 개수는 K+1개여야 한다
    3. 특정 노드의 왼쪽 서브 트리는 특정 노드의 key보다 작은 값들로, 오른쪽 서브 트리는 큰 값들로 구성된다
    4. 최대 M개의 자식 노드를 가질 수 있는 B-Tree 트리를 M차 B-Tree라고 하고
    5. 루트 노드와 리프 노드를 제외한 모든 노드는 ⌈M/2⌉ ~ M개의 자식을 가질 수 있다
    6. 노드의 key는 ⌈M/2⌉-1 ~ M-1개의 key가 포함될 수 있다
    7. 루트 노드는 자신이 리프 노드가 되지 않는 이상 적어도 2개 이상의 자식을 가진다
    8. key값은 중복 되지 않는다
  - 검색 과정
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/3136ba7a-5bcc-448a-b8ab-b95d1607eaf5)
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/df61bcef-5727-44ba-b3ed-e446056fd68e)
    1. 루트 노드에서 시작하여 key들을 왼쪽에서 오른쪽으로 순회하며 검색하고자 하는 K값과 비교한다
       - a-1. 만일 같은 값의 key(key == K)를 찾았다면 검색을 종료한다
       - a-2. 대소관계를 비교하여 (key < K)라면 해당 key의 왼쪽 자식노드로 내려간다
       - a-3. (key > K) 라면 오른쪽 다음 값과 비교하고, 해당 key가 노드의 마지막 값이라면 해당 key의 오른쪽 자식노드로 내려간다 
    2. a.의 과정을 리프 노드에 도달할 때까지 반복하고, 만일 리프노드에도 key(key == K)가 없다면 검색은 실패한다
- 인덱스를 만드는 방법 
  - MySQL
    - 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 클러스트형 인덱스는 테이블당 하나를 설정할 수 있다
    - primary key 또는 unique not null 옵션으로 기본키를 만들면 클러스터형 인덱스를 생성할 수 있다
    - 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼때 생성한다
    - create index 명령어를 사용하면 세컨더리 인덱스를 만들 수 있다
    - 하나의 인덱스(name)만 사용한다면 클러스터형 인덱스가 성능이 더 좋고, 다양한 필드(name, age 등)를 기반으로 쿼리를 보낸다면 세컨더리 인덱스를 사용해야 한다
  - MongoDB
    - 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다
    - 세컨더리키는 부가적으로 설정하며, 기본키와 세컨더리키를 같이 쓴느 복합 인덱스를 설정할 수 있다
- 인덱스 최적화 기법
  - 효과적인 인덱스 생성 전략
    - 인덱스를 설정하는 것은 데이터베이스에 할당된 메모리를 사용하기 때문에 과도한 설정은 성능 부하를 초래한다
    - DML(insert, update, delete)로 인해 데이터 값이 자주 바뀐다면 인덱스 테이블도 수정되어야 하기 때문에 select위주의 테이블에 인덱스를 생성하는 것이 좋다
    - 100만개의 데이터가 있는 테이블이라면 인덱스 스캔이 유리하지만, 10개의 데이터가 있는 테이블이라면 풀 스캔이 유리하다
    - 인덱스를 사용하는 것은 인덱스 테이블을 검색하고, 그 후 컬렉션을 탐색하는 두 번의 검색이 필요하므로 테이블 전체 데이터 중 15% 이하의 데이터를 처리하는 경우에만 효율적이다
  - 복합 인덱스를 생성하는 순서
    1. 어떠한 값과 같음을 비교하는 ==이나 equal 쿼리가 있다면 제일 먼저 인덱스로 설정한다
    2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다
    3. 많은 값을 출력해야 하는 쿼리에 쓰는 필드(쿼리 자체가 > or <)라면 인덱스로 설정한다 
    4. 유니크한 값의 정도(카디널리티)가 높은 순서를 기반으로 인덱스를 설정한다(age보단 email, email보단 name)

### 5. 조인(join)
- 조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 의미한다
- MySQL에서는 JOIN 쿼리로, MongoDB에서는 lookup 쿼리로 조인을 처리한다(MongoDB의 lookup은 성능이 안좋다!)
- 조인의 종류
  - 내부 조인(inner join): 두 테이블의 두 행이 모두 일치하는 부분만 표기한다
    - ```SQL
      SELECT * FROM TableA A
      INNER JOIN TableB ON
      A.key = B.key
      ```  
  - 오른쪽/왼쪽 조인(right/left outer join): 오른쪽/왼쪽 테이블의 모든 행을 결과 테이블에 표기한다
    - ```SQL
      SELECT * FROM TableA A
      RIGHT/LEFT JOIN TableB ON
      A.key = B.key
      ``` 
  - 합집합 조인(full outer join): 두 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기한다
    - ```SQL
      SELECT * FROM TableA A
      FULL OUTER JOIN TableB ON
      A.key = B.key
      ``` 
- 조인의 원리
  - 중첩 루프 조인(NLJ, Nested Loop Join)
    - 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법으로, 랜덤 접근에 대한 비용이 증가하므로 대용량 테이블에는 사용하지 않는다
    - t1, t2 테이블을 조인할 경우, t1 테이블에서 행을 1개 읽은 다음 t2 테이블의 모든 행을 하나씩 읽어 조건에 맞는 레코드를 찾는 것을 t1 테이블의 모든 행에 대하여 반복한다
  - 정렬 병합 조인
    - 각각의 테이블을 조인할 필드를 기준으로 정렬한 후 조인 작업을 수행하는 방법이다
    - 조인할 때 쓸 인덱스가 없고, 조인 조건으로 < 또는 > 등의 범위 비교 연산자가 있을 때 주로 사용한다
  - 해시 조인
    - 해시 테이블을 기반으로 하나의 테이블을 메모리에 온전히 올릴 수 있을 경우 효과적이다(못 올리면 디스크를 사용하는 비용이 발생)
    - 동등 조인에서만 사용할 수 있고, 둘 중에 더 작은 테이블을 기반으로 해시 테이블을 빌드하며, 해시 테이블을 기반으로 일치하는 레코드를 찾는 프로브 단계를 진행한다














                                               