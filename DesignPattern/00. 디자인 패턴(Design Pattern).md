## 디자인 패턴(Design Pattern) 이란
- 디자인 원칙
  - 애플리케이션에서 달라지는 부분을 찾아 내고, 달라지지 않는 부분으로부터 분리시킨다
    - 즉, 바뀌는 부분을 캡슐화 한다
    - 코드에 새로운 요구사항이 있다면 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다
  - 인터페이스(상위형식, supertype)에 맞춰서 프로그래밍 한다
    - 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 집어넣을 수 있다
    - 상속(확장), 인터페이스(구현), A에는 B가 있다(사용, ㅡ>)
  - 행동을 상속받는 대신, 올바른 행동 객체로 구성(composition)되게 한다
    - 일련의 행동 알고리즘군을 캡슐화 할 수 있게 해준다
    - 객체에서 원하는 행동 인터페이스를 구현하기만 하면 실행시에 행동을 바꿀 수 있다
  - 서로 상호작용을 하는 개체 사이에서는 가능하면 느슨하게 결합(loose coupling)하는 디자인을 사용해야 한다
    - 느슨하게 결합하면 변경 사항이 생겨도 객체 사이의 상호의존성을 최소화 할 수 있다
  - OCP(Open-Closed Principle)
    - 클래스는 확장에 대해서는 열려있어야 하지만 코드 변경에 대해서는 닫혀있어야 한다
  - DIP(Dependency Inversion Principle, 의존성 뒤집기 원칙)
    - 추상화된 것에 의존하도록 만들고, 구상 클래스에 의존하도록 만들지 않도록 한다
    - 고수준 구성요소(PizzaStore)가 저수준 구성요소(Pizza 클래스들)에 의존하면 안 된다
  - 최소 지식 원칙(Principle of Least Knowledge)
    - 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수에 주의해야 한다
    - 객체 자체, 메소드에 매개변수로 전달된 객체, 그 메소드에서 생성하거나 인스턴스를 만든 객체, 그 객체에 속하는 구성요소의 4종류의 객체의 메소드만 호출해야 한다
      - ```java
        //원칙을 따르지 않은 경우
        public float getTemp() {
            Thermomether thermometer = station.getThermometer(); //Station클래스에서 Thermometer객체를 받아와서 메소드 호출
            return Thermometer.getTemp();
        }
        //따르는 경우
        public float getTemp() {
            return station.getTemp(); //Station클래스에 Thermometer클래스에 요청을 해서 Temp를 받아오는 메소드를 추가
        }
        ```
  - 헐리우드 원칙(Hollywood Principle)
    - 고수준 구성요소에서 저수준 구성요소가 언제 사용될지 결정한다
    - 의존성 부패(dependency rot)를 방지할 수 있다
      - 고수준 구성요소가 저수준 구성요소에 의존하고 그 저수준 구성요소가 다시 고수준 구성요소에게 의존하는 것처럼 순환의존성이 복잡하게 꼬여있는 상태
  - 단일 역할 원칙
    - 클래스를 바꾸는 이유는 한 가지 뿐이어야 한다
      - 집합체 관리와 반복자 메소드를 처리하는 부분이 하나의 클래스 안에 구현되면 안된다
    - 응집도(cohesion)가 높도록 설계된다
      - 한 클래스 또는 모듈이 특정 목적 또는 역할을 얼마나 일관되게 지원하는지 나타내는 척도




## 전략 패턴(strategy pattern)
- 행동 알고리즘군을 정의하고 각각을 캡술화 하여 교환해서 사용할 수 있도록 만든다
- 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다













                                               