## 프록시 패턴(proxy pattern)
- 어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴
- 원격 프록시(remote proxy)는 원격 객체(remote object)에 대한 로컬 대변자(local representative)역할을 한다
  - 원격 객체란 다른 JVM 힙에서(다른 주소 공간)에서 돌아가고 있는 객체를 의미
  - 로컬 대변자는 어떤 메소드를 호출하면 다른 원격 객체한테 그 메소드 호출을 전달해 주는 역할을 맡고 있는 객체
  - JDK의 rmic툴을 이용해 서비시를 구현한 클라이언트 보조객체(Stub)와 서비스 보조객체(Skeleton)의 클래스를 만들 수 있다
- 클라이언트 객체는 로컬 힙에 들어있는 프록시(proxy)객체의 메소드를 호출하고, 네트워크 통신과 관련된 저수준 작업은 프록시에서 처리한다
  - 자바의 원격 메소드 호출(RMI, Remote Method Invocation)을 사용하여 원격 JVM에 있는 객체를 찾아 메소드를 호출한다
  - 원격 격체의 인스턴스를 만들고 Naming.rebind()를 사용해 RMIregistry에 결합해 클라이언트에서 검색할 수 있게 만든다
  - 클라이언트에서 Stub 객체(프록시)를 가져오기 위해 RMIregistry의 룩업(lookup)을 통해 객체를 요청한다
  - Naming.lookup()의 리턴값으로 Stub 객체가 전달되고 클라이언트는 이 객체를 사용하여 역직렬화하며 통신 한다
- 동적 클래스 다운로딩(dynamic class downloading)을 사용하여 Stub 객체의 교환도 가능
  - 직렬화된 Stub 객체에 그 객체의 클래스 파일이 있는 위치를 나타내는 URL이 내장된다
  - 역직렬화 과정에서 로컬 시스템에서 클래스 파일을 차지 못하면, 내장된 URL로 부터 요청을 통해 클래스 파일을 가져올 수 있다
- 원격 서비스를 돌리기 전에 RMIregistry를 실행시켜야 하고, 인자와 리턴 형식이 직렬화가 가능해야 하고, 클라이언트에 Stub 클래스가 존재해야 한다
  - ```java
    import java.rmi.*;
    import java.rmi.server.*;
    public interface MyRemote extends Remote {
        public String sayHello() throws RemoteException;
    }
    public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
        public MyRemoteImpl() throws RemoteException {}
        public String sayHello() {
            return "Server says, 'Hey'";
        }
        public static void main(String[] args) {
            try {
                MyRemote service = new MyRemoteImpl();
                Naming.rebind("RemoteHello", service);
            } catch(Exception ex) {
                ex.printStackTrace();
            }
        }
    }
    public class MyRemoteClient {
        public static void main(String[] args) {
            new MyRemoteClient().go();
        }
        public void go() {
            try {
                MyRemote service = (MyRemote)Naming.lookup("rmi://127.0.0.1/RemoteHello");
                String req = service.sayHello;
                System.out.println(req);
            } catch(Exception ex) {
                ex.printStackTrace();
            }
        }
    }
    ```
  - ```java
    import java.rmi.*;
    import java.rmi.server.*;
    import java.io.*;
    public interface GumballMachineRemote extedns Remote {
        public int getCount() throws RemoteException;
        public String getLocation() throws RemoteException;
        public State getState() throws RemoteException;
    }
    public interface State extends Serializable {
        public void insertQuarter();
        public void ejectQuarter();
        public void turnCrank();
        public void dispense();
    }
    public class NoQuarterState implements State {
        transient GumballMachine gumballMachine;
        public NoQuarterState(GumballMachine gumballMachine) {
            this.gumballMachine = gumballMachine;
        }
        public void insertQuarter() {
            System.out.println("동전을 넣으셨습니다");
            gumballMachine.setState(gumballMachine.getHasQuarterState());
        }
        ...       
    }
    public class GumballMachine extends UnicastRemoteObject implements GumballMachineRemote {
        State soldOutState;
        State noQuarterState;
        State hasQuarterState;
        State soldState;
        State state = soldOutState;
        String location;
        int count = 0;
          
        public GumballMachine(String location, int numberGumballs) throws RemoteException {
            soldOutState = new SoldOutState(this);
            noQuarterState = new NoQuarterState(this);
            hasQuarterState = new HasQuarterState(this);
            soldState = new SoldState(this);
            this.location = location;
            this.count = numberGumballs;
            if (numberGumballs > 0) {
                state = noQuarterState;
            }
        }
        public void insertQuarter() { state.insertQuarter(); }
        public void ejectQuarter() { state.ejectQuarter(); }
        ...
    }
    public class GumballMachineTest {
        public static void main(String[] args) {
            GumballMachine gumballMachine = null;
            if (args.length < 2) {
                System.out.println("GumballMachine <name> <inventory>");
                System.exit(1);
            }
            try {
                name = args[0];
                count = Integer.parseInt(args[1]);
                gumballMachine = new GumballMachine(name, count);
                Naming.rebind("//' + name + '/gumballmachine', gumballMachine);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
            
    public class GumballMonitor { 
        GumballMachineRemote machine;
        public GumballMonitor(GumballMachineRemote machine) {
            this.machine = machine;
        }
        public void report() {
            try {
                System.out.println("뽑기 위치: " + machine.getLocation());
                System.out.println("현재 재고: " + machine.getCount());
                System.out.println("현재 상태: " + machine.getState());
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    }
    public class GumbalMonitorTest {
        public static void main(String[] args) {
            String[] location = {"rmi://santafe.mightygumball.com/gumballmachine",
                                  "rmi://seattle.mightygumball.com/gumballmachine"};
            GumballMonitor[] monitor = new GumballMonitor[location.lenght];
            for (int i=0; i<location.length; i++) {
                try {
                    GumballMachineRemote machine = (GumballMachineRemote)Naming.lookup(location[i]);
                    monitor[i] = new GumballMonitor(machine);
                    System.out.println(monitor[i]);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            for (int i=0; i<monitor.length; i++) {
                monitor[i].report();
            }
        }
    }
    ```






























