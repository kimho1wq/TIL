# 파이썬이란

- 파이썬(Python)은 1990년에 개발한 인터프리터 언어
  - 인터프리터(interpreter) 언어는 소스코드(source)를 변역과 동시에 실행시킴
  - 컴파일(compile) 언어는 소스코드를 변역(compile)하여 OS가 해석가능한 목적코드(binary file)로 변경하고 그 후에 실행시킴 
  
# 자료형

- 변수
  - 파이썬에서 사용하는 변수는 객체를 가리키는 것
  - 파이썬은 변수에 저장된 값을 스스로 판단하여 자료형의 타입을 지정
  - 파이썬의 객체 참조
    - ```python
      # 대입 연산자
      a = [1, 2, 3]
      b = a
      id(a)  # 4303029896 (a 변수가 가리키는 메모리의 주소)
      id(b)  # 4303029896 (b 변수가 가리키는 메모리의 주소)
      a is b # True (a와 b가 가리키는 객체는 동일)
      a[1] = 4
      print(a, b) # [1, 4, 3], [1, 4, 3]
      
      # [:] 사용
      a = [1, 2, 3]
      b = a[:]
      a is b # False (a와 b가 가리키는 객체가 다름)
      a[1] = 4
      print(a, b) # [1, 4, 3], [1, 2, 3]
      
      # copy 모듈, 함수
      from copy import copy
      a = [1, 2, 3]
      b = copy(a)
      a is b # False (a와 b가 가리키는 객체가 다름)
      b = a.copy()
      a is b # False (a와 b가 가리키는 객체가 다름)
      ```
  - 기타
    - ```python
      a = b = 'python'
      
      a = 3
      b = 5
      a, b = b, a #(두 변수의 값 변경 가능)
      ```
- 숫자
  - 정수(integer)
    - ```python
      a = 123
      a = -178
      a = 0
      ```
  - 실수(floating-point)
    - ```python
      a = 1.2
      a = 4.24E3   #0.00423
      a = 4.24e-3  #0.00423
      ```
  - 8진수(octal): 0o 또는 0O(숫자 0 + 알파벳 소문자 o 또는 대문자 O)로 시작
    - ```python
      a = 0O10    # 10진수: 8
      a = 0o17    # 10진수: 15
      ```
  - 16진수(hexadeciaml): 0x로 시작
    - ```python
      a = 0xf     # 10진수: 15
      a = 0x10    # 10진수: 16
      ```
  - 연산자
    - 사칙연산(+, -, *, /), 제곱(**)
      - ```python
        a = 2 
        b = 5
        a ** b  # 32
        ```
    - 나머지(%), 몫(//)
      - ```python
        a = 7 
        b = 4
        a % b   # 3
        a / b   # 1.75
        a // b  # 1
        ```
- 문자열
  - 문자열 생성
    1. 큰따옴표(")로 양쪽 둘러싸기: ```"Hello World"```
    2. 작은따옴표(')로 양쪽 둘러싸기: ```'Python is fun'```
    3. 큰따옴표 3개를 연속(""")으로 써서 양쪽 둘러싸기: ```"""Life is too short, You need python"""```
    4. 작은따옴표 3개를 연속(''')으로 써서 양쪽 둘러싸기: ```'''Life is too short, You need python'''```
  - 문자열 연산
    - ```python
      a = "Python "
      b = "is fun!"
      a + b   # Python is fun!
      a * 2   # Python Python 
      len(a)  # 7
      a[2]    # t
      a[0:2]  # Pyt
      a[:]    # Python 
      a[1] = 'Y' #에러. 요소값은 변경 불가
      ```
  - 문자열 포맷팅
    - ```python
      number = 3
      print("%d apples" % 3)       # 3 apples
      print("%d apples" % number)  # 3 apples
      print("%s apples" % "five")  # five apples
      print("%d and %s apples"%(number, "five"))  # 3 and five apples
      print("%d%% percents" % 99) # 99% percents
      print("%0.4f" % 3.42134234) # 3.4213
      ```
    - ```python
      number = 3
      print("{0} apples".format(3))        # 3 apples
      print("{0} apples".format(number))   # 3 apples
      print("{0} and {1} apples".format(number, "five"))  # 3 and five apples
      print("{num} and {str} apples".format(num=3, str="five"))  # 3 and five apples
      print("{{and}}".format()) # {and}
      print("{0:0.4f}".format(3.42134234)) # 3.4213
      
      print("{0:<6}".format("Hi"))  # 'Hi    ' (왼쪽정렬)
      print("{0:>6}".format("Hi"))  # '    Hi' (오른쪽정렬)
      print("{0:^6}".format("Hi"))  # '  Hi  ' (가운데정렬)
      print("{0:=^6}".format("Hi")) # '==Hi==' (공백채우기)
      ```
  - 문자열 관련 함수
    - 문자열 삽입
      - ```python
        ",".join('abc')          # 'a,b,c'
        ",".join(['a','b','c'])  # 'a,b,c'
        ```
    - 문자열 바꾸기
      - ```python
        a = "Life is too short"
        a.replace("Life", "Your leg") # 'Your leg is too short'
        ```
    - 문자열 나누기
      - ```python
        a = "Life is too short"
        a.split() # ['Life', 'is', 'too', 'short'] (기본값은 공백)
        ```
    - 문자 개수 세기
      - ```python
        a = 'hobby'
        a.count('b') # 2
        ```
    - 위치 찾기
      - ```python
        a = "Life is too short"
        a.find('t')  # 8, 문자 t가 처음으로 나온 위치를 반환
        a.find('z')  # -1, 찾는 문자가 없을 경우
        a.index('t') # 8, 문자 t가 처음으로 나온 위치를 반환
        a.index('z') # 에러.
        ```
    - 대소문자 변경
      - ```python
        a = "hi"
        a = a.upper() # 'HI'
        a = a.lower() # 'hi'
        ```  
    - 공백 지우기
      - ```python
        a = " hi "
        a.lstrip() # 'hi ' (왼쪽 공백지우기)
        a.rstrip() # '  hi' (오른쪽 공백지우기)
        a.strip()  # 'hi' (양쪽 공백지우기)
        ```
- 리스트
  - 리스트 생성
    - ```python
      a = [] # a=list()와 같음
      b = [1, 2, ['Life', 'is']]
      ```
  - 리스트 연산하기
    - ```python
      a = [1, 2]
      b = [3, 4]
      a + b  # [1, 2, 3, 4]
      a * 2  # [1, 2, 1, 2]
      len(a) # 2
      a[1] + "Hi"      # 에러. 형변환이 필요
      str(a[1]) + "Hi" # "2Hi"
      
      a = [1, 2, 3]
      a[2] = 4 # [1, 2, 4]
      del a[2] # [1, 2] (모든 자료형에 del 함수 사용 가능)
      ```
  - 리스트 관련 함수
    - 리스트에 요소 추가
      - ```python
        a = [1, 2]
        a.append(3)  # [1, 2, 3]
        a.append([4, 5])  # [1, 2, 3, [4, 5]]
        a = [1, 2, 3]
        a.extend([4, 5]) # [1, 2, 3, 4, 5] (a+=[4, 5]와 동일)
        ```
    - 리스트 정렬
      - ```python
        a = [1, 4, 3, 2]
        a.sort() # [1, 2, 3, 4]
        a = ['a', 'c', 'b']
        a.reverse() # ['b', 'c', 'a'] (역순 정렬이 아님)
        a.sort()    # ['a', 'b', 'c']
        ```
    - 요소 개수 세기, 찾기
      - ```python
        a = [1, 2, 3, 1]
        a.count(1) # 2 (x가 몇 개 있는지 조사하여 그 개수를 리턴)
        a.index(3) # 2 (x 요소의 index를 리턴)
        a.index(0) # 에러. 요소가 없으면
        ```
    - 요소 삽입과 제거
      - ```python
        a = [2, 3, 2, 1]
        a.insert(0, 4) # a=[4, 2, 3, 2, 1]
        a.remove(2) # a=[4, 3, 2, 1] (첫 번째로 나오는 x를 삭제, index가 아님)
        a.pop()  # 1 (마지막 요소를 리턴하고 그 요소는 삭제, a=[4, 3, 2])
        a.pop(1) # 3 (x번째 요소를 리턴하고 그 요소는 삭제, a=[4, 2])
        ```
- 튜플
  - 튜플 생성
    - 리스트는 []으로 둘러싸지만 튜플은 ()으로 둘러싼다
    - 리스트는 요소 값의 생성, 삭제, 수정이 가능하지만 튜플은 요소 값을 바꿀 수 없다
    - ```python
      t = ()
      t = (1,)
      t = (1, 2, 3)
      t = 1, 2, 3
      t = ('a', 'b', ('ab', 'cd'))
      
      t[0] = 'c' # 에러. 튜플 요소값 변경 불가
      del t[0]    # 에러. 튜플 요소값 삭제 불가
      ```
  - 튜플의 연산
    - ```python
      t1 = (1, 2)
      t2 = ('a', 'b')
      t3 = t1 * 2   # (1, 2, 1, 2) 
      t4 = t1 + t2  # (1, 2, 'a', 'b')
      t5 = t4[1:] # (2, 'a','b')
      len(t5)     # 3
      ```
- 딕셔너리
  - ```{Key1:Value1, Key2:Value2, Key3:Value3, ...}```
  - 연관 배열(Associative array) 또는 해시(Hash)를 구현한 자료형
  - 중복되는 Key 값은 하나를 제외한 나머지 것들이 모두 무시됨
  - Key에 리스트는 쓸 수 없음, 튜플은 가능(immutable하기 때문) 
  - 딕셔너리 생성
    - ```python
      dic = {'name':'pey'}
      dic[1] = 'a' # {'name':'pey', 1:'a'}
      dic[2] = [1,2] # {'name':'pey', 1:'a', 2:[1,2]}
      print(dic['name']) # 'pey'
      ```
  - 딕셔너리 관련 함수
    - key, value 쌍 얻기
      - ```python
        a = {'name': 'pey', 'phone': '010', 'birth': '1118'}
        a.keys()   # dict_keys(['name', 'phone', 'birth']) (dict_keys 객체 반환)
        a.values() # dict_values(['pey', '010', '1118']) (dict_values 객체 반환)
        a.items()  # dict_items([('name', 'pey')...]) (dict_items 객체 반환)
        
        # (dict_* 객체 모두 for문 사용 가능)
        for k, v in a.items():
            print(k, v)
        ```
    - 요소 얻기
      - ```python
        a = {'name': 'pey'}
        a.get('name')    # 'pey'
        a.get('address') # None
        a.get('address', 'seoul') # "seoul" (디폴트 값 설정 가능)
        a['name']        # 'pey'
        a['address']     # 에러. 
        ```      
    - 요소 지우기
      - ```python
        a = {'name': 'pey', 2:'a', 'list':[1,2]}
        del dic['list']  # {'name':'pey', 2:'a'}
        a.clear()        # {} (모든 요소 삭제)
        ```
    - key가 딕셔너리 안에 있는지 조사하기
      - ```python
        a = {'name': 'pey'}
        'name' in a   # True
        'emaddressail' in a  # False
        ```
- 집합
  - 중복을 허용하지 않는다, 순서가 없다(unordered), 인덱스(index)로 접근 불가
  - 집합 생성
    - ```python
      s = set() # {}
      s = set("Hello")   # {'e', 'H', 'l', 'o'}
      
      s = set([1, 2, 3]) # {1, 2, 3}
      l = list(s)  # [1, 2, 3]
      l[0] # 1
      t = tuple(s) # (1, 2, 3)
      t[0] # 1
      ```
  - 집합 연산
    - 교집합, 합집합, 차집합
      - ```python
        s1 = set([1, 2, 3, 4, 5, 6])
        s2 = set([4, 5, 6, 7, 8, 9])
        
        # 교집합
        s1 & s2 # {4, 5, 6}
        s1.intersection(s2) # {4, 5, 6}
        
        # 합집합
        s1 | s2 # {1, 2, 3, 4, 5, 6, 7, 8, 9}
        s1.union(s2) # {1, 2, 3, 4, 5, 6, 7, 8, 9}
        
        # 차집합
        s1 - s2 # {1, 2, 3}
        s1.difference(s2) # {1, 2, 3}
        s2 - s1 # {8, 9, 7}
        s2.difference(s1) # {8, 9, 7}
        ```
  - 집합 관련 함수들
    - 요소 추가하기
      - ```python
        s = set([1, 2])
        s.add(3)  # {1, 3, 2} (1개의 값만 추가 가능)
        s.update([4, 5]) # {1, 3, 2, 5, 4} (여러개 추가 가능)
        ```
    - 요소 제거하기
      - ```python
        s = set([3, 2, 4, 1])
        s.remove(2) # {1, 4, 3} (특정 x값을 제거)
        ```

- 불(bool)
  - ```True - 참, False - 거짓```
  - bool 자료형은 파이썬의 예약어로 첫 문자는 항상 대문자로 사용
  - 자료형의 참과 거짓
    - 참(True): ```"1", [1], (1), {'1':1}, 1```
    - 거짓(False): ```"", [], (), {}, 0, None```
      - ```python
        a = True
        a       # True
        1 == 1  # True
        2 > 1   # True
        type(a) # <class 'bool'> (x의 자료형을 확인하는 파이썬의 내장 함수)
      
        bool('1') # True
        bool('')  # Fasle
        bool(1)   # True
        bool(0)   # False
        ```

# 제어문과 함수

- if문
  - ```
    if 조건문:
      <수행할 문장1>
      ...
    elif 조건문:
      <수행할 문장2>
      ...
    else:
      <수행할 문장3>
      ...
    ```
  - 조건부 표현식(conditional expression)
    - ```python
      #변수 = 조건문이_참인_경우의_값 if 조건문 else 조건문이_거짓인_경우의_값
      message = "success" if score >= 60 else "failure"
      ```
  - 비교연산자
    - ```x == y```: x와 y가 같다
    - ```x != y```: x와 y가 같지 않다
    - ```x >= y```: x가 y보다 크거나 같다
    - ```x <= y```: x가 y보다 작거나 같다
  - 논리연산자
    - ```x or y``` : x와 y 둘중에 하나만 참이어도 참이다
    - ```x and y```: x와 y 모두 참이어야 참이다
    - ```not x```  : x가 거짓이면 참이다
  - 기타
    - ```x (not) in List```  : x가 List의 요소로 존재하(지 않으)면 True
    - ```x (not) in Tuple``` : x가 Tuple의 요소로 존재하(지 않으)면 True
    - ```x (not) in String```: x가 String의 요소로 존재하(지 않으)면 True
      - ```python
        1 in [1, 2, 3]         # True
        1 not in [1, 2, 3]     # False
        'a' in ('a', 'b', 'c') # True
        'j' not in 'python'    # True
        ```
- while문
  - ```
    while 조건문:
      <수행할 문장1>
      <수행할 문장2>
      ...
    ```
  - continue, break
    - ```python
      x = 1
      while True:
        x = x + 1
        if x % 2 == 0: continue
        if x > 10: break
    
        # 10이하의 홀수만 출력 
        print(x)
      ```
- for문
  - ```
    for 변수 in 리스트(또는 튜플, 문자열):
      <수행할 문장1>
      <수행할 문장2>
      ...
    ```
  - range 함수: 숫자 리스트인 range 객체를 반환
    - ```python
      sum = 0
      for i in range(1, 11): 
        sum += i
      print(sum) # 55
      ```
  - 리스트 컨프리헨션(list comprehension): 리스트 안에 for문을 포함하는 리스트
    - ```
      [표현식 for 항목1 in 반복가능객체1 if 조건문1
        for 항목2 in 반복가능객체2 if 조건문2
        ...
        for 항목n in 반복가능객체n if 조건문n]
      ```
    - ```python
      a = [1, 2, 3, 4]
      result = [num * 3 for num in a] # [3, 6, 9, 12]
      result = [num * 3 for num in a if num % 2 == 0] # [6, 12]
      ```
    - ```python
      # 구구단 예제
      result = [x * y for x in range(2,10)
               for y in range(1,10)]
      # [2, 4, 6, ... 9, 18, 27, ...]
      ```
- 함수
  - 기본 구조
    - ```
      def 함수명(매개변수):
        <수행할 문장1>
        ...
        return 리턴값
      ```
    - ```python
      def add(a, b): 
        return a + b
      print(add(2,3)) # 5
      ```
  - 매개변수에 초깃값 미리 설정 가능
    - ```python
      def add(a, b=1): 
        return a + b
      print(add(2,3)) # 5
      print(add(2))   # 3
      ```
  - 리턴값은 항상 하나만 가능
    - ```python
      def add_and_mul(a,b): 
        return a+b, a*b
      print(add_and_mul(2,3)) # (5, 6) (하나의 튜플값으로 반환됨)
      ```
  - 여러 개의 입력값을 받는 함수
    - ```
      def 함수이름(*매개변수): 
        <수행할 문장>
         ...
      ```
    - ```python
      def cal(choice, *args): 
        if choice == "add":
          result = 0 
          for i in args: 
            result = result + i 
        else:
          ...
        return result 
      print(cal("add", 1,2,3,4,5,6,7,8,9,10)) # 55
      ```
  - 키워드 매개변수 kwargs
    - 매개변수에 **을 붙이면 key=value 형태의 입력값이 그 딕셔너리에 저장됨
    - kwargs(keyword arguments)는 args와 마찬가지로 관례적으로 사용
    - ```python
      def print_kwargs(**kwargs):
        print(kwargs)
      print_kwargs(name='foo', age=3) # {'name': 'foo','age': 3}
      ```
  - global 명령어 사용
    - ```python
      a = 1 
      def vartest(): 
        global a 
        a = a+1

      vartest() 
      print(a)  # 2
      ```
  - 람다(lambda)식
    - 함수를 한줄로 간결하게 만들 때 사용
    - return 명령어가 없어도 표현식의 결과값을 리턴
      - ```함수명 = lambda 매개변수1, 매개변수2, ... : 매개변수를 이용한 표현식```
      - ```python
        add = lambda a, b: a+b
        print(add(3, 4))  # 7
        ```


# 입력과 출력

- 사용자 입력과 출력
  - 입력: input()
    - 사용자가 입력한 모든 것을 문자열로 저장
    - ```str = input("문자를 입력하세요: ")```
  - 출력: print()
    - 한 줄에 결과값 출력 (end 매개변수 사용, 기본값은 '\n')
    - ```python
      for i in range(10):
        print(i, end=' ')
      # 0 1 2 3 4 5 6 7 8 9
      ```
- 파일 읽고 쓰기
  - 파일 객체 생성
    - ```
      파일 객체 = open(파일 경로, 모드)
      'r': 읽기 모드
      'w': 쓰기 모드
      'a': 추가 모드
      ```
    - with문과 함께 사용: 자동으로 close()해줌
      - ```python
        with open("foo.txt", "w") as f:
          f.write("Life is too short, you need python")
        ```
  - 파일 쓰기
    - ```python
      f = open("C:/doit/새파일.txt", 'w')
      for i in range(1, 11):
        data = "%d번째 줄입니다.\n" % i
        f.write(data)
      f.close()
      ```
  - 파일 읽기
    - readline(): 한 줄을 읽음
      - ```python
        # 파일 전체 읽기
        f = open("C:/doit/새파일.txt", 'r')
        while True:
          line = f.readline()
          if not line: break
          print(line)
        f.close()
        ```
    - readlines(): 모든 줄을 읽어, 줄을 요소로 갖는 리스트를 리턴
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        lines = f.readlines()
        for line in lines:
          print(line.strip()) # 줄 끝의 줄 바꿈 문자('\n')를 제거한다.
        f.close()
        ```
    - read(): 파일의 내용 전체를 문자열로 리턴
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        print(f.read())
        f.close()
        ```
    - 파일 객체 사용: for 문과 함께 사용하여 파일을 줄 단위로 읽을 수 있음
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        for line in f:
          print(line)
        f.close()
        ```
- 프로그램의 입력과 출력
  - sys 모듈을 사용하여 프로그램에 인수를 전달할 수 있음
  - ```C:\doit> python sys1.py aaa bbb ccc```
    - ![image](https://user-images.githubusercontent.com/15611500/210804207-b7455846-1a23-4d22-9e51-9cf5023f85eb.png)
    - argv[0]은 파일 이름, argv[1]부터는 인수가 차례로 저장됨
  - ```python
    #sys1.py
    import sys
    
    args = sys.argv[1:]
    for i in args:
      print(i.upper(), end=' ')
    # AAA BBB CCC
    ```

# 클래스, 모듈, 예외 처리

- 클래스
  - 클래스 구조
    - 빈 클래스
      - ```python
        class MyClass:
          pass
        ``` 
    - 사칙연산 클래스
      - ```python
        class Calculator:
          def __init__(self, a, b): #생성자 메소드
            self.a = a
            self.b = b
          def add(self):
            return self.a + self.b
          def mul(self):
            return self.a * self.b
          def sub(self):
            return self.a - self.b
          def div(self):
            return self.a / self.b
        
        cal = Calculator(5, 2)
        print(cal.add()) # 7
        print(cal.mul()) # 10
        print(cal.sub()) # 3
        print(cal.div()) # 2.5
        ```
  - 클래스의 상속
    - ```python
      class MyCal(Calculator):
        def pow(self):
          return self.a ** self.b
      cal = MyCal(5, 2)
      print(cal.add()) # 7
      print(cal.pow()) # 25
      ```
  - 메소드 오버라이딩
    - ```python
      class MyCal(Calculator):
        def div(self):
          return self.a / self.b if self.b != 0 else 0
      cal = MyCal(4, 0)
      print(cal.div()) # 0
      ```
  - 클래스 변수
    - ```python
      class Family:
        lastname = "김"
      f1 = Family()
      f2 = Family()
      print(Family.lastname) # '김'
      print(f1.lastname) # '김'
      print(f2.lastname) # '김'
      
      Family.lastname = "박"
      print(f1.lastname) # '박'
      print(f2.lastname) # '박'
      
      f1.lastname = "최" # 클래스 변수가 변경되지 않고, 새로운 객체변수가 생성됨
      print(f1.lastname) # '최'
      print(f2.lastname) # '박'
      ```
- 모듈
  - 함수나 변수 또는 클래스를 모아 놓은 파이썬 파일(.py의 파일은 모두 모듈)
  - 모듈 만들기
    - ```python
      # mod.py
      PI = 3.141592

      class Math: 
        def solv(self, r): 
          return PI * (r ** 2)
      
      def add(a, b):
        return a + b
      def sub(a, b):
        return a - b
      
      # 다른 파이썬 파일에서 mod1.py(모듈)을 가져다 사용할 때 실행되지 않음
      if __name__ == "__main__":
        print(add(3, 4)) # 7
      ```
  - 모듈 불러오기
    - ```python
      import mod
      #from mod import add, ...
      #from mod import *
      print(mod.add(3, 4)) # 7
      print(mod.PI) # 3.141592
      a = mod.Math()
      print(a.solv(2)) # 12.566368

      ```
    - 모듈을 불러오기 위한 방법
      - sys.path에 사용하고 싶은 모듈의 경로 추가
        - ```sys.path.append("C:/doit/mymod")```
          ```
          print(sys.path)
          ['', 'C:\\Windows\\SYSTEM32\\python311.zip', 'c:\\Python311\\DLLs', 
          'c:\\Python311\\lib', 'c:\\Python311', 'c:\\Python311\\lib\\site-packages', 
          'C:/doit/mymod']
          ```
      - set 명령어를 사용해 PYTHONPATH 환경 변수에 모듈의 경로 추가
        - ```set PYTHONPATH=C:\doit\mymod```
- 패키지
  - 파이썬 모듈을 계층적(디렉터리 구조)으로 관리하기 위함
  - 모듈 이름이 A.B인 경우에 A는 패키지 이름이고, B는 A 패키지의 B모듈
    - ```
      game/
          __init__.py
          sound/
              __init__.py
              echo.py
              wav.py
          graphic/
              __init__.py
              screen.py
              render.py
          play/
              __init__.py
              run.py
              test.py
      ```
    - ```python
      # render.py
      from game.sound.echo import echo_test
      from ..sound.echo import echo_test
      
      echo_test()
      ```
    - ```python
      import game.sound.echo
      game.sound.echo.echo_test() # echo
      
      from game.sound import echo
      echo.echo_test() # echo
      
      from game.sound.echo import echo_test
      echo_test() # echo
      
      # __init__.py 파일에 __all__ 변수를 설정해줘야 함
      from game.sound import *
      echo.echo_test() # __all__ = ['echo'] 가 없으면 에러.

      # game 디렉터리의 __init__.py에 정의한 것만 참조할 수 있음
      import game
      game.sound.echo.echo_test() # 에러.
      
      # 도트 연산자(.)를 사용해서 import할 때 마지막 항목은 모듈 또는 패키지
      import game.sound.echo.echo_test # 에러. 함수이기 때문에 안됨
      ```
  - ```__init__.py```의 용도
    - 해당 디렉터리가 패키지의 일부임을 알려주는 역할을 함
    - python3.3 버전부터는 ```__init__.py``` 파일이 없어도 패키지로 인식한다
- 예외 처리
  - try, finally문
    - ```python
      try:
          f = open('foo.txt', 'w')
          4 / 0
      except ZeroDivisionError as e:
          print(e)
      except Exception as e:
          pass
      finally: # 중간에 오류가 발생하더라도 무조건 실행
          f.close()
      ```
  - try, else문
    - ```python
      try:
          age=int(input('나이를 입력하세요: '))
      except:
          print('입력이 정확하지 않습니다.')
      else: # 오류가 없을 경우에만 수행된다.
          if age <= 18:
              print('미성년자는 출입금지입니다.')
          else:
              print('환영합니다.')
      ```
  - 예외 만들기
    - ```python
      class MyError(Exception):
          # 오류 메시지를 출력하기 위한 메소드
          def __str__(self):
              return "This is a MyError"
      raise MyError()
      ```

# 유용한 함수들

- 내장 함수
  - abs()
    - 절대값을 리턴
    - ```python
      abs(-3) # 3
      abs(-1.2) # 1.2
      ```
  - round()
    - 숫자를 입력받아 반올림하여 리턴
    - ```python
      round(5.678, 2) # 5.68 (소수점 2자리까지만 반올림하여 표시)
      round(4.6) # 5
      ```
  - sum(), max(), min() 
    - 반복 가능한(iterable) 데이터를 입력받아 합, 최대값, 최소값을 리턴
    - ```python
      sum([1, 2, 3]) # 6
      max([1, 2, 3]) # 3
      min([1, 2, 3]) # 1
      max("python")  # 'y'
      min("python")  # 'h'
      ```
  - divmod(a, b), pow(a, b)
    - divmod()는 a를 b로 나눈 몫과 나머지를 튜플로, pow()는 제곱값을 리턴하는 함수
    - ```python
      divmod(7, 3) # (2, 1)
      7 // 3 # 2
      7 % 3  # 1
      
      pow(2, 4) # 16
      pow(3, 3) # 27
      ```
  - hex(), oct()
    - 정수를 입력받아 16진수, 8진수 문자열로 리턴
    - ```python
      hex(234) # '0xea'
      hex(3) # '0x3'
      oct(34) # '0o42'
      oct(12345) # '0o30071'
      ```
  - all()
    - 반복 가능한(iterable) 데이터의 요소가 모두 참이면 True, 아니면 Fasle 반환
    - ```python
      all([1, 2])  # True
      all([1, 2, 0]) # False
      all([]) # True (입력 인수가 빈 값은 경우. 참)
      ```
  - any()
    - 반복 가능한(iterable) 데이터의 요소중 하나라도 참이면 True, 아니면 Fasle 반환
    - ```python
      all([1, 2, 0])  # True
      all(["", 0]) # False
      all([]) # False (입력 인수가 빈 값은 경우. 거짓)
      ``` 
  - id()
    - 객체를 입력받아 객체의 고유 주소 값(레퍼런스)을 리턴
    - ```python
      id(3) # 135072304
      id(4) # 245072292
      
      a = 3
      b = a
      id(a) # 135072304
      id(b) # 135072304
      ```
  - map(func, iterable)
    - 반복 가능한(iterable) 데이터의 각 요소에 함수(func)를 적용한 결과를 리턴
    - ```python
      def two_times(x): 
          return x*2
      
      list(map(two_times, [1, 2, 3, 4])) # [2, 4, 6, 8]
      list(map(lambda x: x*2, [1, 2, 3, 4])) # [2, 4, 6, 8]
      ```
  - filter(func, iterable)
    - 반복 가능한(iterable) 데이터로 함수(func)를 호출했을 때, 반환 값이 참인 것만 묶어서(걸러 내서) 리턴
    - ```python
      def positive(x):
          return x > 0

      list(filter(positive, [1, -3, 2, 0, -5, 6])) # [1, 2, 6]
      list(filter(lambda x: x>0, [1, -3, 2, 0, -5, 6])) # [1, 2, 6]
      ```
  - enumerate()
    - 반복 가능한(iterable) 데이터를 입력받아 인덱스 값을 포함하는 enumerate 객체를 리턴
    - ```python
      for idx, name in enumerate(['body', 'foo', 'bar']):
          print(idx, name, end=', ') # 0 body, 1 foo, 2 bar, 
      ```
  - zip(*iterable)
    - 반복 가능한(iterable) 데이터의 다발을 동일한 개수로 이루어진 데이터로 묶어서 리턴
    - ```python
      list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)]
      list(zip("abc", "def")) # [('a', 'd'), ('b', 'e'), ('c', 'f')]
      ```
  - isinstance(object, class)
    - 객체(object)가 해당 클래스(class)의 인스턴스(instance)이면 True 아니면 False 반환
    - ```python
      a = Person()
      b = 3
      isinstance(a, Person) # True
      isinstance(b, Person) # False
      ```
  - sorted()
    - 반복 가능한(iterable) 데이터를 정렬한 후 그 결과를 리스트로 리턴
    - ```python
      sorted([3, 1, 2]) # [1, 2, 3]
      sorted("zero") # ['e', 'o', 'r', 'z']
      ```
  - type()
    - 입력값의 자료형이 무엇인지 알려 주는 함수
    - ```python
      type("abc") # <class 'str'>
      type([ ]) # <class 'list'>
      type(open("test", 'w')) # <class '_io.TextIOWrapper'>
      ```
  - input()
    - 사용자 입력을 문자열로 받는 함수
    - ```python
      a = input()
      b = input("내용을 입력하시오: ")
      ```
  - chr(), ord()
    - chr()는 유니코드 숫자값을 입력받아 문자를 생성 , ord()는 그 반대
    - ```python
      chr(97)    # 'a'
      chr(44032) # '가'
      ord('a') # 97
      ord('가') # 44032
      ```
  - dir()
    - 해당 객체가 사용가능한 함수와 변수를 보여줌
    - ```python
      dir([1, 2, 3]) # ['append', 'insert', 'pop',...]
      dir({'1':'a'}) # ['clear', 'items', 'keys',...]
      ```
  - eval()
    - 문자열로 구성된 표현식을 입력으로 받아 해당 문자열을 실행한 결괏값을 리턴
    - ```python
      eval('1+2') # 3
      eval("'hi' + 'a'") # 'hia'
      eval('divmod(4, 3)') # (1, 1)
      ```
- 표준 라이브러리
  - 파이썬을 설치할 때 자동으로 컴퓨터에 설치 (sys, re 모듈 등)
  - datetime
    - 년, 월, 일로 날짜를 표현할 때 사용하는 모듈
    - ```python
      import datatime
      
      day1 = datetime.date(2019, 12, 14)
      day2 = datetime.date(2021, 6, 5)
      Dday = day2 - day1 
      Dday.days # 539
      Dday.weekday() # 5 (0~6, 월요일~일요일)
      Dday.isoweekday() # 6 (1~7, 월요일~일요일)
      ```
  - time
    - 시간과 관련된 모듈
    - ```python
      import time
      
      # UTC(Universal Time Coordinated 협정 세계 표준시)를 사용
      time.time() # 988458015.73417199 (1970/1/1 00:00:00를 기준으로 지난 시간을 초 단위로 돌려줌)
      time.localtime(time.time()) # time.struct_time(tm_year=2013, tm_mon=5, tm_mday=21, tm_hour=16, ...)
      time.asctime(time.localtime(time.time())) # 'Sat Apr 28 20:50:20 2001'
      time.ctime() # 'Sat Apr 28 20:56:31 2001'
      time.strftime('%x', time.localtime(time.time())) # '05/01/01'
      time.strftime('%c', time.localtime(time.time())) # '05/01/01 17:22:21'
      
      time.sleep(1) # 초 단위로 쓰레드에 sleep을 걸음
      ```
  - math
    - 수학 관련 모듈
    - ```python
      import math
      
      # 최대공약수(gcd, greatest common divisor), 파이썬 3.5부터 사용 가능
      math.gcd(60, 100, 80) # 20
      # 최소공배수(lcm, least common multiple), 파이썬 3.9부터 사용 가능
      math.lcm(15, 25) # 75
      ```
  - random
    - 난수(규칙이 없는 임의의 수) 발생 모듈
    - ```python
      import random
      
      # 0.0에서 1.0 사이의 실수
      random.random() # 0.5384
      # 1에서 10 사이의 정수
      random.randint(1, 10) # 6
      # 입력으로 받은 리스트에서 무작위로 하나를 선택
      random.choice([1,2,3,4,5]) # 2
      # 리스트 요소를 무작위로 n개 선택하여 섞음
      random.sample([1,2,3,4,5], 4) # [3,5,1,2]
      ```
  - itertools
    - 반복 가능한(iterable) 데이터 관련 모듈
    - ```python
      import itertools
      
      students = ['한민서', '황지민', '이광수']
      snacks = ['사탕', '초콜릿']
      list(zip(students, snacks)) # [('한민서', '사탕'), ('황지민', '초콜릿')]
      
      # zip에선 안되는, 요소의 개수가 서로 다를 경우 초기값 설정 가능
      list(itertools.zip_longest(students, snacks, fillvalue='새우깡')) # [('한민서', '사탕'), ('황지민', '초콜릿'), ('이광수', '새우깡')]
      # 요소 n개를 선택한 순열(permutations)을 iterator로 리턴
      list(itertools.permutations(['1','2','3'], 2)) # [('1','2'),('1','3'),('2','1'),('2','3'),('3','1'),('3','2')]
      # 요소 n개를 선택한 조합(combinations)을 iterator로 리턴
      list(itertools.combinations(['1','2','3'], 2)) # [('1','2'),('1','3'),('2','3')]
      # iterator의 개수만 세려면 len() 함수 이용
      len(list(itertools.combinations(range(1, 46), 6))) # 8145060
      # 같은 숫자의 중복을 허용하는 조합(combinations)
      len(list(itertools.combinations_with_replacement(range(1, 46), 6))) # 15890700
      ```
  - functools
    - 반복 가능한(iterable) 데이터 관련 모듈
    - ```python
      import functools
      
      # 요소에 차례대로(왼쪽에서 오른쪽으로) 누적 적용하여 하나의 값으로 만드는 함수
      data = [1, 2, 3, 4, 5]
      functools.reduce(lambda x,y: x+y, data) # 15 (sum값 계산)
      functools.reduce(lambda x,y: x if x>y else y, data) # 5 (max값 계산)
      ```
  - operator
    - 다양한 기준으로 정렬할 수 있도록 도와주는 모듈
    - ```python
      import operator
      
      students1 = [("jane" 22,'A'),("dave",32,'B'),("sally",17,'B')]
      students2 = [{"name":"jane","age":22,"grade": 'A'},
                {"name":"dave","age":32,"grade":'B'},
                {"name": "sally","age":17,"grade":'B'}]
      # 나이 순서대로 정렬 (오름차순)
      sorted(students1, key=operator.itemgetter(1)) # [('sally',17,'B'),('jane',22,'A'),('dave',32,'B')]
      sorted(students2, key=operator.itemgetter('age')) # [('sally',17,'B'),('jane',22,'A'),('dave',32,'B')]
      ```
  - shutil
    - 파일을 복사(copy)하거나 이동(move)할 때 사용하는 모듈
    - ```python
      import shutil

      shutil.copy("c:/doit/a.txt", "c:/temp/a.txt.bak") # 복사
      shutil.move("c:/doit/a.txt", "c:/temp/a.txt") # 이동
      ```
  - glob
    - 디렉터리 안의 파일들을 읽어주는 모듈
    - ```python
      import glob
      
      # 디렉터리 안의 파일들을 읽어서 리턴
      glob.glob.("C:/doit/mark*") # ['c:/doit\\marks1.py', 'c:/doit\\marks2.py', 'c:/doit\\marks3.py']
      ```
  - pickle
    - 객체의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈
    - ```python
      import pickle
      data = {1: 'python', 2: 'you need'}
      with open("test.txt", 'wb') as f:
        pickle.dump(data, f)
      with open("test.txt", 'rb') as f:
        data = pickle.load(f)
      ```
  - os
    - 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈
    - ```python
      import os
      
      # 현재 시스템의 환경 변수 값
      os.environ # environ({'PROGRAMFILES': 'C:\\Program Files', 'APPDATA': ...})
      # PATH 환경변수 
      os.environ['PATH'] # 'C:\\ProgramData\\Java\\javapath;...
      # 현재 디렉터리 위치를 변경
      os.chdir("C:\WINDOWS")
      # 현재 자신의 디렉터리 위치를 리턴
      os.getcwd() # 'C:\WINDOWS'
      # 시스템 명령어 호출하기 
      os.system("dir") # 시스템 명령어 dir을 실행
      # 시스템 명령어를 실행한 결과값을 읽기 모드 형태의 파일 객체로 리턴
      f = os.popen("dir")
      f.read()
      # 디렉터리를 생성 및 삭제
      os.mkdir("C:\TestDir")
      os.rmdir("C:\TestDir") # (디렉토리가 비어있어야 가능)
      # 파일 이름 변경
      os.rename(src, dst) # src파일을 dst라는 이름으로 바꿈
      ```
  - zipfile
    - 여러 개의 파일을 zip 형식으로 합치거나 이를 해제할 때 사용하는 모듈
    - ```python
      import zipfile
      
      # 파일 합치기 (a.txt, b.txt)
      with zipfile.ZipFile('Test.zip', 'w') as f:
          f.write('a.txt')
          f.write('b.txt')
      # 모든 파일 해제하기
      with zipfile.ZipFile('Test.zip') as f:
          f.extractall()
      # 특정 파일 해제하기
      with zipfile.ZipFile('Test.zip') as f:
          f.extract('a.txt') 
      
      # 파일을 압축하여 묶고 싶은 경우
        # ZIP_STORED - 압축하지 않고 파일을 Zip으로만 묶는다. 속도가 빠르다.
        # ZIP_DEFLATED - 일반적인 ZIP 압축으로 속도가 빠르고 압축률은 낮다. (호환성이 좋다.)
        # ZIP_BZIP2 - bzip2 압축으로 압축률이 높고 속도가 느리다.
        # ZIP_LZMA - lzma 압축으로 압축률이 높고 속도가 느리다. (7zip과 동일한 알고리즘으로 알려져 있다.)
        # compressionlevel은 압축 수준으로, 1은 속도가 가장 빠르고 압축률이 낮고, 9는 속도는 가장 느리지만 최대 압축
      with zipfile.ZipFile('CTest.zip', 'w',
        compression=zipfile.ZIP_LZMA, compresslevel=9) as f:
          f.write('a.txt')
          f.write('b.txt')
      ```
  - threading
    - 쓰레드를 구현한 모듈
    - ```python
      import time
      import threading

      def test_method():
          for i in range(5):
              time.sleep(1)
              print("working:%s\n" % i)

      print("Start")

      threads = []
      for i in range(5):
          threads.append(threading.Thread(target=test_method))

      for t in threads:
          t.start()

      for t in threads:
          t.join()  # join으로 스레드가 종료될때까지 기다린다

      print("End")
      ```
  - tempfile
    - 파일을 임시로 만들어서 사용할 때 유용한 모듈
    - ```python
      import tempfile
      
      # 중복되지 않는 임시 파일의 이름을 무작위로 만듬
      filename = tempfile.mkstemp() # 'C:\WINDOWS\TEMP\~-275151-0'
      # 임시 저장 공간으로 사용할 파일 객체를 리턴, 바이너리 쓰기 모드(wb)
      f = tempfile.TemporaryFile()
      f.close() # close가 호출되면 자동으로 삭제됨
      ```
  - traceback
    - 실행 중 발생한 오류를 추적하고자 할 때 사용하는 모듈
    - ```python
      import traceback
      
      def a():
          return 1/0
      def b():
          a()
      def main():
          try:
              b()
          except:
              print("오류가 발생했습니다.")
              print(traceback.format_exc()) # 오류 추적 결과를 문자열로 리턴
      main()
      ```
      ```
      오류가 발생했습니다.
      Traceback (most recent call last):
        File "c:\doit\traceback_sample.py", line 14, in main
          b()
        File "c:\doit\traceback_sample.py", line 9, in b
          a()
        File "c:\doit\traceback_sample.py", line 5, in a
          return 1/0
      ZeroDivisionError: division by zero
      ```
  - json
    - JSON 데이터를 쉽게 처리하고자 사용하는 모듈
    - ```python
      import json
      
      info = {'name': '홍길동', 'birth': '0525', 'age': 30}
      with open('info.json', 'w') as f:
          json.dumps(info, f, indent=4, ensure_ascii=False) # ensure_ascii=False는 한글 문자열이 아스키 형태로 변경되는 것을 방지

      with open('info.json', 'r') as f:
          data = json.load(f)
      type(data)  # <class 'dict'>
      print(data) # {'name': '홍길동', 'birth': '0525', 'age': 30}
      ```
      ```
      [myinfo.json]
      {
          "name": "홍길동",
          "birth": "0525",
          "age": 30
      }
      ```
  - urllib
    - url을 읽고 분석할 때 사용하는 모듈
    - ```python
      import urllib.request
      
      # wikidocks page의 리소스 내용을 파일로 저장
      resource = 'https://wikidocs.net/12'
      with urllib.request.urlopen(resource) as s:
          with open('wikidocs_12.html', 'wb') as f:
              f.write(s.read())
      ```
  - webbrowser
    - 시스템 브라우저를 호출할 때 사용하는 모듈
    - ```python
      import webbrowser
      
      # 해당 사이트를 새 창으로 열기
      webbrowser.open_new('http://python.org')
      # 이미 열린 브라우저로 원하는 사이트를 열기
      webbrowser.open('http://python.org')
      ```
- 외부 라이브러리
  - PyPI(Python Package Index)는 100,000건 이상의 파이썬 패키지가 모인 저장 공간
  - pip를 이용하여 외부 모듈이나 패키지를 설치할 수 있음
    - ```pip install SomePackage==1.0.4 ```
    - ```
      pip list
        
      Package                  Version
      ------------------------ --------
      amqp                     2.1.4
      anyjson                  0.3.3
      ...
      ```














































