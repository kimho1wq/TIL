# 파이썬이란

- 파이썬(Python)은 1990년에 개발한 인터프리터 언어
  - 인터프리터(interpreter) 언어는 소스코드(source)를 변역과 동시에 실행시킴
  - 컴파일(compile) 언어는 소스코드를 변역(compile)하여 OS가 해석가능한 목적코드(binary file)로 변경하고 그 후에 실행시킴 
  
# 자료형

- 변수
  - 파이썬에서 사용하는 변수는 객체를 가리키는 것
  - 파이썬은 변수에 저장된 값을 스스로 판단하여 자료형의 타입을 지정
  - 파이썬의 객체 참조
    - ```python
      # 대입 연산자
      a = [1, 2, 3]
      b = a
      id(a)  # 4303029896 (a 변수가 가리키는 메모리의 주소)
      id(b)  # 4303029896 (b 변수가 가리키는 메모리의 주소)
      a is b # True (a와 b가 가리키는 객체는 동일)
      a[1] = 4
      print(a, b) # [1, 4, 3], [1, 4, 3]
      
      # [:] 사용
      a = [1, 2, 3]
      b = a[:]
      a is b # False (a와 b가 가리키는 객체가 다름)
      a[1] = 4
      print(a, b) # [1, 4, 3], [1, 2, 3]
      
      # copy 모듈, 함수
      from copy import copy
      a = [1, 2, 3]
      b = copy(a)
      a is b # False (a와 b가 가리키는 객체가 다름)
      b = a.copy()
      a is b # False (a와 b가 가리키는 객체가 다름)
      ```
  - 기타
    - ```python
      a = b = 'python'
      
      a = 3
      b = 5
      a, b = b, a #(두 변수의 값 변경 가능)
      ```
- 숫자
  - 정수(integer)
    - ```python
      a = 123
      a = -178
      a = 0
      ```
  - 실수(floating-point)
    - ```python
      a = 1.2
      a = 4.24E3   #0.00423
      a = 4.24e-3  #0.00423
      ```
  - 8진수(octal): 0o 또는 0O(숫자 0 + 알파벳 소문자 o 또는 대문자 O)로 시작
    - ```python
      a = 0O10    # 10진수: 8
      a = 0o17    # 10진수: 15
      ```
  - 16진수(hexadeciaml): 0x로 시작
    - ```python
      a = 0xf     # 10진수: 15
      a = 0x10    # 10진수: 16
      ```
  - 연산자
    - 사칙연산(+, -, *, /), 제곱(**)
      - ```python
        a = 2 
        b = 5
        a ** b  # 32
        ```
    - 나머지(%), 몫(//)
      - ```python
        a = 7 
        b = 4
        a % b   # 3
        a / b   # 1.75
        a // b  # 1
        ```
- 문자열
  - 문자열 생성
    1. 큰따옴표(")로 양쪽 둘러싸기: ```"Hello World"```
    2. 작은따옴표(')로 양쪽 둘러싸기: ```'Python is fun'```
    3. 큰따옴표 3개를 연속(""")으로 써서 양쪽 둘러싸기: ```"""Life is too short, You need python"""```
    4. 작은따옴표 3개를 연속(''')으로 써서 양쪽 둘러싸기: ```'''Life is too short, You need python'''```
  - 문자열 연산
    - ```python
      a = "Python "
      b = "is fun!"
      a + b   # Python is fun!
      a * 2   # Python Python 
      len(a)  # 7
      a[2]    # t
      a[0:2]  # Pyt
      a[:]    # Python 
      a[1] = 'Y' #에러. 요소값은 변경 불가
      ```
  - 문자열 포맷팅
    - ```python
      number = 3
      print("%d apples" % 3)       # 3 apples
      print("%d apples" % number)  # 3 apples
      print("%s apples" % "five")  # five apples
      print("%d and %s apples"%(number, "five"))  # 3 and five apples
      print("%d%% percents" % 99) # 99% percents
      print("%0.4f" % 3.42134234) # 3.4213
      ```
    - ```python
      number = 3
      print("{0} apples".format(3))        # 3 apples
      print("{0} apples".format(number))   # 3 apples
      print("{0} and {1} apples".format(number, "five"))  # 3 and five apples
      print("{num} and {str} apples".format(num=3, str="five"))  # 3 and five apples
      print("{{and}}".format()) # {and}
      print("{0:0.4f}".format(3.42134234)) # 3.4213
      
      print("{0:<6}".format("Hi"))  # 'Hi    ' (왼쪽정렬)
      print("{0:>6}".format("Hi"))  # '    Hi' (오른쪽정렬)
      print("{0:^6}".format("Hi"))  # '  Hi  ' (가운데정렬)
      print("{0:=^6}".format("Hi")) # '==Hi==' (공백채우기)
      ```
  - 문자열 관련 함수
    - 문자열 삽입
      - ```python
        ",".join('abc')          # 'a,b,c'
        ",".join(['a','b','c'])  # 'a,b,c'
        ```
    - 문자열 바꾸기
      - ```python
        a = "Life is too short"
        a.replace("Life", "Your leg") # 'Your leg is too short'
        ```
    - 문자열 나누기
      - ```python
        a = "Life is too short"
        a.split() # ['Life', 'is', 'too', 'short'] (기본값은 공백)
        ```
    - 문자 개수 세기
      - ```python
        a = 'hobby'
        a.count('b') # 2
        ```
    - 위치 찾기
      - ```python
        a = "Life is too short"
        a.find('t')  # 8, 문자 t가 처음으로 나온 위치를 반환
        a.find('z')  # -1, 찾는 문자가 없을 경우
        a.index('t') # 8, 문자 t가 처음으로 나온 위치를 반환
        a.index('z') # 에러.
        ```
    - 대소문자 변경
      - ```python
        a = "hi"
        a = a.upper() # 'HI'
        a = a.lower() # 'hi'
        ```  
    - 공백 지우기
      - ```python
        a = " hi "
        a.lstrip() # 'hi ' (왼쪽 공백지우기)
        a.rstrip() # '  hi' (오른쪽 공백지우기)
        a.strip()  # 'hi' (양쪽 공백지우기)
        ```
- 리스트
  - 리스트 생성
    - ```python
      a = [] # a=list()와 같음
      b = [1, 2, ['Life', 'is']]
      ```
  - 리스트 연산하기
    - ```python
      a = [1, 2]
      b = [3, 4]
      a + b  # [1, 2, 3, 4]
      a * 2  # [1, 2, 1, 2]
      len(a) # 2
      a[1] + "Hi"      # 에러. 형변환이 필요
      str(a[1]) + "Hi" # "2Hi"
      
      a = [1, 2, 3]
      a[2] = 4 # [1, 2, 4]
      del a[2] # [1, 2] (모든 자료형에 del 함수 사용 가능)
      ```
  - 리스트 관련 함수
    - 리스트에 요소 추가
      - ```python
        a = [1, 2]
        a.append(3)  # [1, 2, 3]
        a.append([4, 5])  # [1, 2, 3, [4, 5]]
        a = [1, 2, 3]
        a.extend([4, 5]) # [1, 2, 3, 4, 5] (a+=[4, 5]와 동일)
        ```
    - 리스트 정렬
      - ```python
        a = [1, 4, 3, 2]
        a.sort() # [1, 2, 3, 4]
        a = ['a', 'c', 'b']
        a.reverse() # ['b', 'c', 'a'] (역순 정렬이 아님)
        a.sort()    # ['a', 'b', 'c']
        ```
    - 요소 개수 세기, 찾기
      - ```python
        a = [1, 2, 3, 1]
        a.count(1) # 2 (x가 몇 개 있는지 조사하여 그 개수를 리턴)
        a.index(3) # 2 (x 요소의 index를 리턴)
        a.index(0) # 에러. 요소가 없으면
        ```
    - 요소 삽입과 제거
      - ```python
        a = [2, 3, 2, 1]
        a.insert(0, 4) # a=[4, 2, 3, 2, 1]
        a.remove(2) # a=[4, 3, 2, 1] (첫 번째로 나오는 x를 삭제, index가 아님)
        a.pop()  # 1 (마지막 요소를 리턴하고 그 요소는 삭제, a=[4, 3, 2])
        a.pop(1) # 3 (x번째 요소를 리턴하고 그 요소는 삭제, a=[4, 2])
        ```
- 튜플
  - 튜플 생성
    - 리스트는 []으로 둘러싸지만 튜플은 ()으로 둘러싼다
    - 리스트는 요소 값의 생성, 삭제, 수정이 가능하지만 튜플은 요소 값을 바꿀 수 없다
    - ```python
      t = ()
      t = (1,)
      t = (1, 2, 3)
      t = 1, 2, 3
      t = ('a', 'b', ('ab', 'cd'))
      
      t[0] = 'c' # 에러. 튜플 요소값 변경 불가
      del t[0]    # 에러. 튜플 요소값 삭제 불가
      ```
  - 튜플의 연산
    - ```python
      t1 = (1, 2)
      t2 = ('a', 'b')
      t3 = t1 * 2   # (1, 2, 1, 2) 
      t4 = t1 + t2  # (1, 2, 'a', 'b')
      t5 = t4[1:] # (2, 'a','b')
      len(t5)     # 3
      ```
- 딕셔너리
  - ```{Key1:Value1, Key2:Value2, Key3:Value3, ...}```
  - 연관 배열(Associative array) 또는 해시(Hash)를 구현한 자료형
  - 중복되는 Key 값은 하나를 제외한 나머지 것들이 모두 무시됨
  - Key에 리스트는 쓸 수 없음, 튜플은 가능(immutable하기 때문) 
  - 딕셔너리 생성
    - ```python
      dic = {'name':'pey'}
      dic[1] = 'a' # {'name':'pey', 1:'a'}
      dic[2] = [1,2] # {'name':'pey', 1:'a', 2:[1,2]}
      print(dic['name']) # 'pey'
      ```
  - 딕셔너리 관련 함수
    - key, value 쌍 얻기
      - ```python
        a = {'name': 'pey', 'phone': '010', 'birth': '1118'}
        a.keys()   # dict_keys(['name', 'phone', 'birth']) (dict_keys 객체 반환)
        a.values() # dict_values(['pey', '010', '1118']) (dict_values 객체 반환)
        a.items()  # dict_items([('name', 'pey')...]) (dict_items 객체 반환)
        
        # (dict_* 객체 모두 for문 사용 가능)
        for k, v in a.items():
            print(k, v)
        ```
    - 요소 얻기
      - ```python
        a = {'name': 'pey'}
        a.get('name')    # 'pey'
        a.get('address') # None
        a.get('address', 'seoul') # "seoul" (디폴트 값 설정 가능)
        a['name']        # 'pey'
        a['address']     # 에러. 
        ```      
    - 요소 지우기
      - ```python
        a = {'name': 'pey', 2:'a', 'list':[1,2]}
        del dic['list']  # {'name':'pey', 2:'a'}
        a.clear()        # {} (모든 요소 삭제)
        ```
    - key가 딕셔너리 안에 있는지 조사하기
      - ```python
        a = {'name': 'pey'}
        'name' in a   # True
        'emaddressail' in a  # False
        ```
- 집합
  - 중복을 허용하지 않는다, 순서가 없다(unordered), 인덱스(index)로 접근 불가
  - 집합 생성
    - ```python
      s = set() # {}
      s = set("Hello")   # {'e', 'H', 'l', 'o'}
      
      s = set([1, 2, 3]) # {1, 2, 3}
      l = list(s)  # [1, 2, 3]
      l[0] # 1
      t = tuple(s) # (1, 2, 3)
      t[0] # 1
      ```
  - 집합 연산
    - 교집합, 합집합, 차집합
      - ```python
        s1 = set([1, 2, 3, 4, 5, 6])
        s2 = set([4, 5, 6, 7, 8, 9])
        
        # 교집합
        s1 & s2 # {4, 5, 6}
        s1.intersection(s2) # {4, 5, 6}
        
        # 합집합
        s1 | s2 # {1, 2, 3, 4, 5, 6, 7, 8, 9}
        s1.union(s2) # {1, 2, 3, 4, 5, 6, 7, 8, 9}
        
        # 차집합
        s1 - s2 # {1, 2, 3}
        s1.difference(s2) # {1, 2, 3}
        s2 - s1 # {8, 9, 7}
        s2.difference(s1) # {8, 9, 7}
        ```
  - 집합 관련 함수들
    - 요소 추가하기
      - ```python
        s = set([1, 2])
        s.add(3)  # {1, 3, 2} (1개의 값만 추가 가능)
        s.update([4, 5]) # {1, 3, 2, 5, 4} (여러개 추가 가능)
        ```
    - 요소 제거하기
      - ```python
        s = set([3, 2, 4, 1])
        s.remove(2) # {1, 4, 3} (특정 x값을 제거)
        ```

- 불(bool)
  - ```True - 참, False - 거짓```
  - bool 자료형은 파이썬의 예약어로 첫 문자는 항상 대문자로 사용
  - 자료형의 참과 거짓
    - 참(True): ```"1", [1], (1), {'1':1}, 1```
    - 거짓(False): ```"", [], (), {}, 0, None```
      - ```python
        a = True
        a       # True
        1 == 1  # True
        2 > 1   # True
        type(a) # <class 'bool'> (x의 자료형을 확인하는 파이썬의 내장 함수)
      
        bool('1') # True
        bool('')  # Fasle
        bool(1)   # True
        bool(0)   # False
        ```

# 제어문과 함수

- if문
  - ```
    if 조건문:
      <수행할 문장1>
      ...
    elif 조건문:
      <수행할 문장2>
      ...
    else:
      <수행할 문장3>
      ...
    ```
  - 조건부 표현식(conditional expression)
    - ```python
      #변수 = 조건문이_참인_경우의_값 if 조건문 else 조건문이_거짓인_경우의_값
      message = "success" if score >= 60 else "failure"
      ```
  - 비교연산자
    - ```x == y```: x와 y가 같다
    - ```x != y```: x와 y가 같지 않다
    - ```x >= y```: x가 y보다 크거나 같다
    - ```x <= y```: x가 y보다 작거나 같다
  - 논리연산자
    - ```x or y``` : x와 y 둘중에 하나만 참이어도 참이다
    - ```x and y```: x와 y 모두 참이어야 참이다
    - ```not x```  : x가 거짓이면 참이다
  - 기타
    - ```x (not) in List```  : x가 List의 요소로 존재하(지 않으)면 True
    - ```x (not) in Tuple``` : x가 Tuple의 요소로 존재하(지 않으)면 True
    - ```x (not) in String```: x가 String의 요소로 존재하(지 않으)면 True
      - ```python
        1 in [1, 2, 3]         # True
        1 not in [1, 2, 3]     # False
        'a' in ('a', 'b', 'c') # True
        'j' not in 'python'    # True
        ```
- while문
  - ```
    while 조건문:
      <수행할 문장1>
      <수행할 문장2>
      ...
    ```
  - continue, break
    - ```python
      x = 1
      while True:
        x = x + 1
        if x % 2 == 0: continue
        if x > 10: break
    
        # 10이하의 홀수만 출력 
        print(x)
      ```
- for문
  - ```
    for 변수 in 리스트(또는 튜플, 문자열):
      <수행할 문장1>
      <수행할 문장2>
      ...
    ```
  - range 함수: 숫자 리스트인 range 객체를 반환
    - ```python
      sum = 0
      for i in range(1, 11): 
        sum += i
      print(sum) # 55
      ```
  - 리스트 컨프리헨션(list comprehension): 리스트 안에 for문을 포함하는 리스트
    - ```
      [표현식 for 항목1 in 반복가능객체1 if 조건문1
        for 항목2 in 반복가능객체2 if 조건문2
        ...
        for 항목n in 반복가능객체n if 조건문n]
      ```
    - ```python
      a = [1, 2, 3, 4]
      result = [num * 3 for num in a] # [3, 6, 9, 12]
      result = [num * 3 for num in a if num % 2 == 0] # [6, 12]
      ```
    - ```python
      # 구구단 예제
      result = [x * y for x in range(2,10)
               for y in range(1,10)]
      # [2, 4, 6, ... 9, 18, 27, ...]
      ```
- 함수
  - 기본 구조
    - ```
      def 함수명(매개변수):
        <수행할 문장1>
        ...
        return 리턴값
      ```
    - ```python
      def add(a, b): 
        return a + b
      print(add(2,3)) # 5
      ```
  - 매개변수에 초깃값 미리 설정 가능
    - ```python
      def add(a, b=1): 
        return a + b
      print(add(2,3)) # 5
      print(add(2))   # 3
      ```
  - 리턴값은 항상 하나만 가능
    - ```python
      def add_and_mul(a,b): 
        return a+b, a*b
      print(add_and_mul(2,3)) # (5, 6) (하나의 튜플값으로 반환됨)
      ```
  - 여러 개의 입력값을 받는 함수
    - ```
      def 함수이름(*매개변수): 
        <수행할 문장>
         ...
      ```
    - ```python
      def cal(choice, *args): 
        if choice == "add":
          result = 0 
          for i in args: 
            result = result + i 
        else:
          ...
        return result 
      print(cal("add", 1,2,3,4,5,6,7,8,9,10)) # 55
      ```
  - 키워드 매개변수 kwargs
    - 매개변수에 **을 붙이면 key=value 형태의 입력값이 그 딕셔너리에 저장됨
    - kwargs(keyword arguments)는 args와 마찬가지로 관례적으로 사용
    - ```python
      def print_kwargs(**kwargs):
        print(kwargs)
      print_kwargs(name='foo', age=3) # {'name': 'foo','age': 3}
      ```
  - global 명령어 사용
    - ```python
      a = 1 
      def vartest(): 
        global a 
        a = a+1

      vartest() 
      print(a)  # 2
      ```
  - 람다(lambda)식
    - 함수를 한줄로 간결하게 만들 때 사용
    - return 명령어가 없어도 표현식의 결과값을 리턴
      - ```함수명 = lambda 매개변수1, 매개변수2, ... : 매개변수를 이용한 표현식```
      - ```python
        add = lambda a, b: a+b
        print(add(3, 4))  # 7
        ```


# 입력과 출력

- 사용자 입력과 출력
  - 입력: input()
    - 사용자가 입력한 모든 것을 문자열로 저장
    - ```str = input("문자를 입력하세요: ")```
  - 출력: print()
    - 한 줄에 결과값 출력 (end 매개변수 사용, 기본값은 '\n')
    - ```python
      for i in range(10):
        print(i, end=' ')
      # 0 1 2 3 4 5 6 7 8 9
      ```
- 파일 읽고 쓰기
  - 파일 객체 생성
    - ```
      파일 객체 = open(파일 경로, 모드)
      'r': 읽기 모드
      'w': 쓰기 모드
      'a': 추가 모드
      ```
    - with문과 함께 사용: 자동으로 close()해줌
      - ```python
        with open("foo.txt", "w") as f:
          f.write("Life is too short, you need python")
        ```
  - 파일 쓰기
    - ```python
      f = open("C:/doit/새파일.txt", 'w')
      for i in range(1, 11):
        data = "%d번째 줄입니다.\n" % i
        f.write(data)
      f.close()
      ```
  - 파일 읽기
    - readline(): 한 줄을 읽음
      - ```python
        # 파일 전체 읽기
        f = open("C:/doit/새파일.txt", 'r')
        while True:
          line = f.readline()
          if not line: break
          print(line)
        f.close()
        ```
    - readlines(): 모든 줄을 읽어, 줄을 요소로 갖는 리스트를 리턴
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        lines = f.readlines()
        for line in lines:
          print(line.strip()) # 줄 끝의 줄 바꿈 문자('\n')를 제거한다.
        f.close()
        ```
    - read(): 파일의 내용 전체를 문자열로 리턴
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        print(f.read())
        f.close()
        ```
    - 파일 객체 사용: for 문과 함께 사용하여 파일을 줄 단위로 읽을 수 있음
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        for line in f:
          print(line)
        f.close()
        ```
- 프로그램의 입력과 출력
  - sys 모듈을 사용하여 프로그램에 인수를 전달할 수 있음
  - ```C:\doit> python sys1.py aaa bbb ccc```
    - ![image](https://user-images.githubusercontent.com/15611500/210804207-b7455846-1a23-4d22-9e51-9cf5023f85eb.png)
    - argv[0]은 파일 이름, argv[1]부터는 인수가 차례로 저장됨
  - ```python
    #sys1.py
    import sys
    
    args = sys.argv[1:]
    for i in args:
      print(i.upper(), end=' ')
    # AAA BBB CCC
    ```

# 클래스, 모듈, 예외 처리

- 클래스
  - 클래스 구조
    - 빈 클래스
      - ```python
        class MyClass:
          pass
        ``` 
    - 사칙연산 클래스
      - ```python
        class Calculator:
          def __init__(self, a, b): #생성자 메소드
            self.a = a
            self.b = b
          def add(self):
            return self.a + self.b
          def mul(self):
            return self.a * self.b
          def sub(self):
            return self.a - self.b
          def div(self):
            return self.a / self.b
        
        cal = Calculator(5, 2)
        print(cal.add()) # 7
        print(cal.mul()) # 10
        print(cal.sub()) # 3
        print(cal.div()) # 2.5
        ```
  - 클래스의 상속
    - ```python
      class MyCal(Calculator):
        def pow(self):
          return self.a ** self.b
      cal = MyCal(5, 2)
      print(cal.add()) # 7
      print(cal.pow()) # 25
      ```
  - 메소드 오버라이딩
    - ```python
      class MyCal(Calculator):
        def div(self):
          return self.a / self.b if self.b != 0 else 0
      cal = MyCal(4, 0)
      print(cal.div()) # 0
      ```
  - 클래스 변수
    - ```python
      class Family:
        lastname = "김"
      f1 = Family()
      f2 = Family()
      print(Family.lastname) # '김'
      print(f1.lastname) # '김'
      print(f2.lastname) # '김'
      
      Family.lastname = "박"
      print(f1.lastname) # '박'
      print(f2.lastname) # '박'
      
      f1.lastname = "최" # 클래스 변수가 변경되지 않고, 새로운 객체변수가 생성됨
      print(f1.lastname) # '최'
      print(f2.lastname) # '박'
      ```
- 모듈
  - 함수나 변수 또는 클래스를 모아 놓은 파이썬 파일(.py의 파일은 모두 모듈)
  - 모듈 만들기
    - ```python
      # mod.py
      PI = 3.141592

      class Math: 
        def solv(self, r): 
          return PI * (r ** 2)
      
      def add(a, b):
        return a + b
      def sub(a, b):
        return a - b
      
      # 다른 파이썬 파일에서 mod1.py(모듈)을 가져다 사용할 때 실행되지 않음
      if __name__ == "__main__":
        print(add(3, 4)) # 7
      ```
  - 모듈 불러오기
    - ```python
      import mod
      #from mod import add, ...
      #from mod import *
      print(mod.add(3, 4)) # 7
      print(mod.PI) # 3.141592
      a = mod.Math()
      print(a.solv(2)) # 12.566368

      ```
    - 모듈을 불러오기 위한 방법
      - sys.path에 사용하고 싶은 모듈의 경로 추가
        - ```sys.path.append("C:/doit/mymod")```
          ```
          print(sys.path)
          ['', 'C:\\Windows\\SYSTEM32\\python311.zip', 'c:\\Python311\\DLLs', 
          'c:\\Python311\\lib', 'c:\\Python311', 'c:\\Python311\\lib\\site-packages', 
          'C:/doit/mymod']
          ```
      - set 명령어를 사용해 PYTHONPATH 환경 변수에 모듈의 경로 추가
        - ```set PYTHONPATH=C:\doit\mymod```
- 패키지
  - 파이썬 모듈을 계층적(디렉터리 구조)으로 관리하기 위함
  - 모듈 이름이 A.B인 경우에 A는 패키지 이름이고, B는 A 패키지의 B모듈
    - ```
      game/
          __init__.py
          sound/
              __init__.py
              echo.py
              wav.py
          graphic/
              __init__.py
              screen.py
              render.py
          play/
              __init__.py
              run.py
              test.py
      ```
    - ```python
      # render.py
      from game.sound.echo import echo_test
      from ..sound.echo import echo_test
      
      echo_test()
      ```
    - ```python
      import game.sound.echo
      game.sound.echo.echo_test() # echo
      
      from game.sound import echo
      echo.echo_test() # echo
      
      from game.sound.echo import echo_test
      echo_test() # echo
      
      # __init__.py 파일에 __all__ 변수를 설정해줘야 함
      from game.sound import *
      echo.echo_test() # __all__ = ['echo'] 가 없으면 에러.

      # game 디렉터리의 __init__.py에 정의한 것만 참조할 수 있음
      import game
      game.sound.echo.echo_test() # 에러.
      
      # 도트 연산자(.)를 사용해서 import할 때 마지막 항목은 모듈 또는 패키지
      import game.sound.echo.echo_test # 에러. 함수이기 때문에 안됨
      ```
  - ```__init__.py```의 용도
    - 해당 디렉터리가 패키지의 일부임을 알려주는 역할을 함
    - python3.3 버전부터는 ```__init__.py``` 파일이 없어도 패키지로 인식한다
- 예외 처리
  - try, finally문
    - ```python
      try:
          f = open('foo.txt', 'w')
          4 / 0
      except ZeroDivisionError as e:
          print(e)
      except Exception as e:
          pass
      finally: # 중간에 오류가 발생하더라도 무조건 실행
          f.close()
      ```
  - try, else문
    - ```python
      try:
          age=int(input('나이를 입력하세요: '))
      except:
          print('입력이 정확하지 않습니다.')
      else: # 오류가 없을 경우에만 수행된다.
          if age <= 18:
              print('미성년자는 출입금지입니다.')
          else:
              print('환영합니다.')
      ```
  - 예외 만들기
    - ```python
      class MyError(Exception):
          # 오류 메시지를 출력하기 위한 메소드
          def __str__(self):
              return "This is a MyError"
      raise MyError()
      ```

# 유용한 함수들

- 내장 함수
  - abs















































