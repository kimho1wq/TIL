# 파이썬이란

- 파이썬(Python)은 1990년에 개발한 인터프리터 언어
  - 인터프리터(interpreter) 언어는 소스코드(source)를 변역과 동시에 실행시킴
  - 컴파일(compile) 언어는 소스코드를 변역(compile)하여 OS가 해석가능한 목적코드(binary file)로 변경하고 그 후에 실행시킴 
  
# 자료형

- 변수
  - 파이썬에서 사용하는 변수는 객체를 가리키는 것
  - 파이썬은 변수에 저장된 값을 스스로 판단하여 자료형의 타입을 지정
  - 파이썬의 객체 참조
    - ```python
      # 대입 연산자
      a = [1, 2, 3]
      b = a
      id(a)  # 4303029896 (a 변수가 가리키는 메모리의 주소)
      id(b)  # 4303029896 (b 변수가 가리키는 메모리의 주소)
      a is b # True (a와 b가 가리키는 객체는 동일)
      a[1] = 4
      print(a, b) # [1, 4, 3], [1, 4, 3]
      
      # [:] 사용
      a = [1, 2, 3]
      b = a[:]
      a is b # False (a와 b가 가리키는 객체가 다름)
      a[1] = 4
      print(a, b) # [1, 4, 3], [1, 2, 3]
      
      # copy 모듈, 함수
      from copy import copy
      a = [1, 2, 3]
      b = copy(a)
      a is b # False (a와 b가 가리키는 객체가 다름)
      b = a.copy()
      a is b # False (a와 b가 가리키는 객체가 다름)
      ```
  - 기타
    - ```python
      a = b = 'python'
      
      a = 3
      b = 5
      a, b = b, a #(두 변수의 값 변경 가능)
      ```
- 숫자
  - 정수(integer)
    - ```python
      a = 123
      a = -178
      a = 0
      ```
  - 실수(floating-point)
    - ```python
      a = 1.2
      a = 4.24E3   #0.00423
      a = 4.24e-3  #0.00423
      ```
  - 8진수(octal): 0o 또는 0O(숫자 0 + 알파벳 소문자 o 또는 대문자 O)로 시작
    - ```python
      a = 0O10    # 10진수: 8
      a = 0o17    # 10진수: 15
      ```
  - 16진수(hexadeciaml): 0x로 시작
    - ```python
      a = 0xf     # 10진수: 15
      a = 0x10    # 10진수: 16
      ```
  - 연산자
    - 사칙연산(+, -, *, /), 제곱(**)
      - ```python
        a = 2 
        b = 5
        a ** b  # 32
        ```
    - 나머지(%), 몫(//)
      - ```python
        a = 7 
        b = 4
        a % b   # 3
        a / b   # 1.75
        a // b  # 1
        ```
- 문자열
  - 문자열 생성
    1. 큰따옴표(")로 양쪽 둘러싸기: ```"Hello World"```
    2. 작은따옴표(')로 양쪽 둘러싸기: ```'Python is fun'```
    3. 큰따옴표 3개를 연속(""")으로 써서 양쪽 둘러싸기: ```"""Life is too short, You need python"""```
    4. 작은따옴표 3개를 연속(''')으로 써서 양쪽 둘러싸기: ```'''Life is too short, You need python'''```
  - 문자열 연산
    - ```python
      a = "Python "
      b = "is fun!"
      a + b   # Python is fun!
      a * 2   # Python Python 
      len(a)  # 7
      a[2]    # t
      a[0:2]  # Pyt
      a[:]    # Python 
      a[1] = 'Y' #에러. 요소값은 변경 불가
      ```
  - 문자열 포맷팅
    - ```python
      number = 3
      print("%d apples" % 3)       # 3 apples
      print("%d apples" % number)  # 3 apples
      print("%s apples" % "five")  # five apples
      print("%d and %s apples"%(number, "five"))  # 3 and five apples
      print("%d%% percents" % 99) # 99% percents
      print("%0.4f" % 3.42134234) # 3.4213
      ```
    - ```python
      number = 3
      print("{0} apples".format(3))        # 3 apples
      print("{0} apples".format(number))   # 3 apples
      print("{0} and {1} apples".format(number, "five"))  # 3 and five apples
      print("{num} and {str} apples".format(num=3, str="five"))  # 3 and five apples
      print("{{and}}".format()) # {and}
      print("{0:0.4f}".format(3.42134234)) # 3.4213
      
      print("{0:<6}".format("Hi"))  # 'Hi    ' (왼쪽정렬)
      print("{0:>6}".format("Hi"))  # '    Hi' (오른쪽정렬)
      print("{0:^6}".format("Hi"))  # '  Hi  ' (가운데정렬)
      print("{0:=^6}".format("Hi")) # '==Hi==' (공백채우기)
      ```
  - 문자열 관련 함수
    - 문자열 삽입
      - ```python
        ",".join('abc')          # 'a,b,c'
        ",".join(['a','b','c'])  # 'a,b,c'
        ```
    - 특정 문자열이 포함되었는지 확인
      - ```python
        str = "1234666121"
        str.find("666")       # 4 (index 리턴, 없으면 -1)
        "666" in str          # True
        ```
    - 문자열 바꾸기
      - ```python
        a = "Life is too short"
        a.replace("Life", "Your leg") # 'Your leg is too short'
        ```
    - 문자열 나누기
      - ```python
        a = "Life is too short"
        a.split() # ['Life', 'is', 'too', 'short'] (기본값은 공백)
        ```
    - 문자 개수 세기
      - ```python
        a = 'hobby'
        a.count('b') # 2
        ```
    - 위치 찾기
      - ```python
        a = "Life is too short"
        a.find('t')  # 8, 문자 t가 처음으로 나온 위치를 반환
        a.find('z')  # -1, 찾는 문자가 없을 경우
        a.index('t') # 8, 문자 t가 처음으로 나온 위치를 반환
        a.index('z') # 에러.
        ```
    - 대소문자 변경
      - ```python
        a = "hi"
        a = a.upper() # 'HI'
        a = a.lower() # 'hi'
        ```  
    - 공백 지우기
      - ```python
        a = " hi "
        a.lstrip() # 'hi ' (왼쪽 공백지우기)
        a.rstrip() # '  hi' (오른쪽 공백지우기)
        a.strip()  # 'hi' (양쪽 공백지우기)
        ```
- 리스트
  - 리스트 생성
    - ```python
      a = [] # a=list()와 같음
      b = [1, 2, ['Life', 'is']]
      ```
  - 리스트 연산하기
    - ```python
      a = [1, 2]
      b = [3, 4]
      a + b  # [1, 2, 3, 4]
      a * 2  # [1, 2, 1, 2]
      len(a) # 2
      a[1] + "Hi"      # 에러. 형변환이 필요
      str(a[1]) + "Hi" # "2Hi"
      
      a = [1, 2, 3]
      a[2] = 4 # [1, 2, 4]
      del a[2] # [1, 2] (모든 자료형에 del 함수 사용 가능)
      ```
  - 리스트 관련 함수
    - 리스트에 요소 추가
      - ```python
        a = [1, 2]
        a.append(3)  # [1, 2, 3]
        a.append([4, 5])  # [1, 2, 3, [4, 5]]
        a = [1, 2, 3]
        a.extend([4, 5]) # [1, 2, 3, 4, 5] (a+=[4, 5]와 동일)
        ```
    - 리스트 정렬
      - ```python
        a = [1, 4, 3, 2]
        a.sort() # [1, 2, 3, 4]
        a = ['a', 'c', 'b']
        a.reverse() # ['b', 'c', 'a'] (역순 정렬이 아님)
        a.sort()    # ['a', 'b', 'c']
        ```
    - 요소 개수 세기, 찾기
      - ```python
        a = [1, 2, 3, 1]
        a.count(1) # 2 (x가 몇 개 있는지 조사하여 그 개수를 리턴)
        a.index(3) # 2 (x 요소의 index를 리턴)
        a.index(0) # 에러. 요소가 없으면
        ```
    - 요소 삽입과 제거
      - ```python
        a = [2, 3, 2, 1]
        a.insert(0, 4) # a=[4, 2, 3, 2, 1]
        a.remove(2) # a=[4, 3, 2, 1] (첫 번째로 나오는 x를 삭제, index가 아님)
        a.pop()  # 1 (마지막 요소를 리턴하고 그 요소는 삭제, a=[4, 3, 2])
        a.pop(1) # 3 (x번째 요소를 리턴하고 그 요소는 삭제, a=[4, 2])
        ```
- 튜플
  - 튜플 생성
    - 리스트는 []으로 둘러싸지만 튜플은 ()으로 둘러싼다
    - 리스트는 요소 값의 생성, 삭제, 수정이 가능하지만 튜플은 요소 값을 바꿀 수 없다
    - ```python
      t = ()
      t = (1,)
      t = (1, 2, 3)
      t = 1, 2, 3
      t = ('a', 'b', ('ab', 'cd'))
      
      t[0] = 'c' # 에러. 튜플 요소값 변경 불가
      del t[0]    # 에러. 튜플 요소값 삭제 불가
      ```
  - 튜플의 연산
    - ```python
      t1 = (1, 2)
      t2 = ('a', 'b')
      t3 = t1 * 2   # (1, 2, 1, 2) 
      t4 = t1 + t2  # (1, 2, 'a', 'b')
      t5 = t4[1:] # (2, 'a','b')
      len(t5)     # 3
      ```
- 딕셔너리
  - ```{Key1:Value1, Key2:Value2, Key3:Value3, ...}```
  - 연관 배열(Associative array) 또는 해시(Hash)를 구현한 자료형
  - 중복되는 Key 값은 하나를 제외한 나머지 것들이 모두 무시됨
  - Key에 리스트는 쓸 수 없음, 튜플은 가능(immutable하기 때문) 
  - 딕셔너리 생성
    - ```python
      dic = {'name':'pey'}
      dic[1] = 'a' # {'name':'pey', 1:'a'}
      dic[2] = [1,2] # {'name':'pey', 1:'a', 2:[1,2]}
      print(dic['name']) # 'pey'
      ```
  - 딕셔너리 관련 함수
    - key, value 쌍 얻기
      - ```python
        a = {'name': 'pey', 'phone': '010', 'birth': '1118'}
        a.keys()   # dict_keys(['name', 'phone', 'birth']) (dict_keys 객체 반환)
        a.values() # dict_values(['pey', '010', '1118']) (dict_values 객체 반환)
        a.items()  # dict_items([('name', 'pey')...]) (dict_items 객체 반환)
        
        # (dict_* 객체 모두 for문 사용 가능)
        for k, v in a.items():
            print(k, v)
        ```
    - 요소 얻기
      - ```python
        a = {'name': 'pey'}
        a.get('name')    # 'pey'
        a.get('address') # None
        a.get('address', 'seoul') # "seoul" (디폴트 값 설정 가능)
        a['name']        # 'pey'
        a['address']     # 에러. 
        ```      
    - 요소 지우기
      - ```python
        a = {'name': 'pey', 2:'a', 'list':[1,2]}
        del dic['list']  # {'name':'pey', 2:'a'}
        a.clear()        # {} (모든 요소 삭제)
        ```
    - key가 딕셔너리 안에 있는지 조사하기
      - ```python
        a = {'name': 'pey'}
        'name' in a   # True
        'emaddressail' in a  # False
        ```
- 집합
  - 중복을 허용하지 않는다, 순서가 없다(unordered), 인덱스(index)로 접근 불가
  - 집합 생성
    - ```python
      s = set() # {}
      s = set("Hello")   # {'e', 'H', 'l', 'o'}
      
      s = set([1, 2, 3]) # {1, 2, 3}
      l = list(s)  # [1, 2, 3]
      l[0] # 1
      t = tuple(s) # (1, 2, 3)
      t[0] # 1
      ```
  - 집합 연산
    - 교집합, 합집합, 차집합
      - ```python
        s1 = set([1, 2, 3, 4, 5, 6])
        s2 = set([4, 5, 6, 7, 8, 9])
        
        # 교집합
        s1 & s2 # {4, 5, 6}
        s1.intersection(s2) # {4, 5, 6}
        
        # 합집합
        s1 | s2 # {1, 2, 3, 4, 5, 6, 7, 8, 9}
        s1.union(s2) # {1, 2, 3, 4, 5, 6, 7, 8, 9}
        
        # 차집합
        s1 - s2 # {1, 2, 3}
        s1.difference(s2) # {1, 2, 3}
        s2 - s1 # {8, 9, 7}
        s2.difference(s1) # {8, 9, 7}
        ```
  - 집합 관련 함수들
    - 요소 추가하기
      - ```python
        s = set([1, 2])
        s.add(3)  # {1, 3, 2} (1개의 값만 추가 가능)
        s.update([4, 5]) # {1, 3, 2, 5, 4} (여러개 추가 가능)
        ```
    - 요소 제거하기
      - ```python
        s = set([3, 2, 4, 1])
        s.remove(2) # {1, 4, 3} (특정 x값을 제거)
        ```

- 불(bool)
  - ```True - 참, False - 거짓```
  - bool 자료형은 파이썬의 예약어로 첫 문자는 항상 대문자로 사용
  - 자료형의 참과 거짓
    - 참(True): ```"1", [1], (1), {'1':1}, 1```
    - 거짓(False): ```"", [], (), {}, 0, None```
      - ```python
        a = True
        a       # True
        1 == 1  # True
        2 > 1   # True
        type(a) # <class 'bool'> (x의 자료형을 확인하는 파이썬의 내장 함수)
      
        bool('1') # True
        bool('')  # Fasle
        bool(1)   # True
        bool(0)   # False
        ```
- 기타
  - in, not in 연산자
    - 연속적인 자료구조에 속한 멤버를 확인하기 위한 연산자
    - list, tuple
      - Average : O(n)
      - 하나하나 순회하기 때문에 O(n)만큼의 시간복잡도를 갖는다
    - set, dictionary
      - Average : O(1), Worst : O(n)
      - 내부적으로 hash를 통해 저장하므로 접근하는 시간은 O(1)이다.
      - 하지만 해쉬의 충돌이 많아 성능이 떨어지는 경우 O(n)이 걸릴 수도 있다.



# 제어문과 함수

- if문
  - ```
    if 조건문:
      <수행할 문장1>
      ...
    elif 조건문:
      <수행할 문장2>
      ...
    else:
      <수행할 문장3>
      ...
    ```
  - 조건부 표현식(conditional expression)
    - ```python
      #변수 = 조건문이_참인_경우의_값 if 조건문 else 조건문이_거짓인_경우의_값
      message = "success" if score >= 60 else "failure"
      ```
  - 비교연산자
    - ```x == y```: x와 y가 같다
    - ```x != y```: x와 y가 같지 않다
    - ```x >= y```: x가 y보다 크거나 같다
    - ```x <= y```: x가 y보다 작거나 같다
  - 논리연산자
    - ```x or y``` : x와 y 둘중에 하나만 참이어도 참이다
    - ```x and y```: x와 y 모두 참이어야 참이다
    - ```not x```  : x가 거짓이면 참이다
  - 기타
    - ```x (not) in List```  : x가 List의 요소로 존재하(지 않으)면 True
    - ```x (not) in Tuple``` : x가 Tuple의 요소로 존재하(지 않으)면 True
    - ```x (not) in String```: x가 String의 요소로 존재하(지 않으)면 True
      - ```python
        1 in [1, 2, 3]         # True
        1 not in [1, 2, 3]     # False
        'a' in ('a', 'b', 'c') # True
        'j' not in 'python'    # True
        ```
- while문
  - ```
    while 조건문:
      <수행할 문장1>
      <수행할 문장2>
      ...
    ```
  - continue, break
    - ```python
      x = 1
      while True:
        x = x + 1
        if x % 2 == 0: continue
        if x > 10: break
    
        # 10이하의 홀수만 출력 
        print(x)
      ```
- for문
  - ```
    for 변수 in 리스트(또는 튜플, 문자열):
      <수행할 문장1>
      <수행할 문장2>
      ...
    ```
  - range 함수: 숫자 리스트인 range 객체를 반환
    - ```python
      sum = 0
      for i in range(1, 11): 
        sum += i
      print(sum) # 55
      ```
  - 리스트 컨프리헨션(list comprehension): 리스트 안에 for문을 포함하는 리스트
    - ```
      [표현식 for 항목1 in 반복가능객체1 if 조건문1
        for 항목2 in 반복가능객체2 if 조건문2
        ...
        for 항목n in 반복가능객체n if 조건문n]
      ```
    - ```python
      a = [1, 2, 3, 4]
      result = [num * 3 for num in a] # [3, 6, 9, 12]
      result = [num * 3 for num in a if num % 2 == 0] # [6, 12]
      ```
    - ```python
      # 구구단 예제
      result = [x * y for x in range(2,10)
               for y in range(1,10)]
      # [2, 4, 6, ... 9, 18, 27, ...]
      ```
- 함수
  - 기본 구조
    - ```
      def 함수명(매개변수):
        <수행할 문장1>
        ...
        return 리턴값
      ```
    - ```python
      def add(a, b): 
        return a + b
      print(add(2,3)) # 5
      ```
  - 매개변수에 초깃값 미리 설정 가능
    - ```python
      def add(a, b=1): 
        return a + b
      print(add(2,3)) # 5
      print(add(2))   # 3
      ```
  - 리턴값은 항상 하나만 가능
    - ```python
      def add_and_mul(a,b): 
        return a+b, a*b
      print(add_and_mul(2,3)) # (5, 6) (하나의 튜플값으로 반환됨)
      ```
  - *args, **kwargs
    - 여러 개의 입력값을 받는 함수 (*args)
      - 매개변수에 *을 붙이면, 여러개의 입력 인수가 튜플로 변환하여 매개변수에 저장됨
        - ```python
          def cal(choice, *args): 
            if choice == "add":
              result = 0 
              for i in args: 
                result = result + i 
            else:
              ...
            return result 
          print(cal("add", 1,2,3,4,5,6,7,8,9,10)) # 55
          ```
    - 키워드 매개변수 (**kwargs)
      - 매개변수에 **을 붙이면 key=value 형태의 입력값이 그 딕셔너리에 저장됨
      - kwargs(keyword arguments)는 args와 마찬가지로 관례적으로 사용
        - ```python
          def print_kwargs(**kwargs):
            print(kwargs)
          print_kwargs(name='foo', age=3) # {'name': 'foo','age': 3}
          ```
    - 동시에 사용하기
      - ```python
        def func(*args, **kwargs):
          print("args: ", args)
          print("kwargs: ", kwargs)
      
        func(1, 2, 3, name='foo', age=3)
        # args: (1, 2, 3)
        # kwargs: {'age': 3, 'name': 'foo'}
        ```
  - global 명령어 사용
    - ```python
      a = 1 
      def vartest(): 
        global a 
        a = a+1

      vartest() 
      print(a)  # 2
      ```
  - 람다(lambda)식
    - 함수를 한줄로 간결하게 만들 때 사용
    - return 명령어가 없어도 표현식의 결과값을 리턴
      - ```함수명 = lambda 매개변수1, 매개변수2, ... : 매개변수를 이용한 표현식```
      - ```python
        add = lambda a, b: a+b
        print(add(3, 4))  # 7
        ```


# 입력과 출력

- 사용자 입력과 출력
  - 입력: input()
    - 사용자가 입력한 모든 것을 문자열로 저장
    - ```str = input("문자를 입력하세요: ")```
  - 출력: print()
    - 한 줄에 결과값 출력 (end 매개변수 사용, 기본값은 '\n')
    - ```python
      for i in range(10):
        print(i, end=' ')
      # 0 1 2 3 4 5 6 7 8 9
      ```
- 파일 읽고 쓰기
  - 파일 객체 생성
    - ```
      파일 객체 = open(파일 경로, 모드)
      'r': 읽기 모드
      'w': 쓰기 모드
      'a': 추가 모드
      ```
    - with문과 함께 사용: 자동으로 close()해줌
      - ```python
        with open("foo.txt", "w") as f:
          f.write("Life is too short, you need python")
        ```
  - 파일 쓰기
    - ```python
      f = open("C:/doit/새파일.txt", 'w')
      for i in range(1, 11):
        data = "%d번째 줄입니다.\n" % i
        f.write(data)
      f.close()
      ```
  - 파일 읽기
    - readline(): 한 줄을 읽음
      - ```python
        # 파일 전체 읽기
        f = open("C:/doit/새파일.txt", 'r')
        while True:
          line = f.readline()
          if not line: break
          print(line)
        f.close()
        ```
    - readlines(): 모든 줄을 읽어, 줄을 요소로 갖는 리스트를 리턴
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        lines = f.readlines()
        for line in lines:
          print(line.strip()) # 줄 끝의 줄 바꿈 문자('\n')를 제거한다.
        f.close()
        ```
    - read(): 파일의 내용 전체를 문자열로 리턴
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        print(f.read())
        f.close()
        ```
    - 파일 객체 사용: for 문과 함께 사용하여 파일을 줄 단위로 읽을 수 있음
      - ```python
        f = open("C:/doit/새파일.txt", 'r')
        for line in f:
          print(line)
        f.close()
        ```
- 프로그램의 입력과 출력
  - sys 모듈을 사용하여 프로그램에 인수를 전달할 수 있음
  - ```C:\doit> python sys1.py aaa bbb ccc```
    - ![image](https://user-images.githubusercontent.com/15611500/210804207-b7455846-1a23-4d22-9e51-9cf5023f85eb.png)
    - argv[0]은 파일 이름, argv[1]부터는 인수가 차례로 저장됨
  - ```python
    #sys1.py
    import sys
    
    args = sys.argv[1:]
    for i in args:
      print(i.upper(), end=' ')
    # AAA BBB CCC
    ```

# 클래스, 모듈, 예외 처리

- 클래스
  - 클래스 구조
    - 빈 클래스
      - ```python
        class MyClass:
          pass
        ``` 
    - 사칙연산 클래스
      - ```python
        class Calculator:
          def __init__(self, a, b): #생성자 메소드
            self.a = a
            self.b = b
          def add(self):
            return self.a + self.b
          def mul(self):
            return self.a * self.b
          def sub(self):
            return self.a - self.b
          def div(self):
            return self.a / self.b
        
        cal = Calculator(5, 2)
        print(cal.add()) # 7
        print(cal.mul()) # 10
        print(cal.sub()) # 3
        print(cal.div()) # 2.5
        ```
  - 클래스의 상속
    - ```python
      class MyCal(Calculator):
        def pow(self):
          return self.a ** self.b
      cal = MyCal(5, 2)
      print(cal.add()) # 7
      print(cal.pow()) # 25
      ```
  - 메소드 오버라이딩
    - ```python
      class MyCal(Calculator):
        def div(self):
          return self.a / self.b if self.b != 0 else 0
      cal = MyCal(4, 0)
      print(cal.div()) # 0
      ```
  - 클래스 변수
    - ```python
      class Family:
        lastname = "김"
      f1 = Family()
      f2 = Family()
      print(Family.lastname) # '김'
      print(f1.lastname) # '김'
      print(f2.lastname) # '김'
      
      Family.lastname = "박"
      print(f1.lastname) # '박'
      print(f2.lastname) # '박'
      
      f1.lastname = "최" # 클래스 변수가 변경되지 않고, 새로운 객체변수가 생성됨
      print(f1.lastname) # '최'
      print(f2.lastname) # '박'
      ```
- 모듈
  - 함수나 변수 또는 클래스를 모아 놓은 파이썬 파일(.py의 파일은 모두 모듈)
  - 모듈 만들기
    - ```python
      # mod.py
      PI = 3.141592

      class Math: 
        def solv(self, r): 
          return PI * (r ** 2)
      
      def add(a, b):
        return a + b
      def sub(a, b):
        return a - b
      
      # 다른 파이썬 파일에서 mod1.py(모듈)을 가져다 사용할 때 실행되지 않음
      if __name__ == "__main__":
        print(add(3, 4)) # 7
      ```
  - 모듈 불러오기
    - ```python
      import mod
      #from mod import add, ...
      #from mod import *
      print(mod.add(3, 4)) # 7
      print(mod.PI) # 3.141592
      a = mod.Math()
      print(a.solv(2)) # 12.566368

      ```
    - 모듈을 불러오기 위한 방법
      - sys.path에 사용하고 싶은 모듈의 경로 추가
        - ```sys.path.append("C:/doit/mymod")```
          ```
          print(sys.path)
          ['', 'C:\\Windows\\SYSTEM32\\python311.zip', 'c:\\Python311\\DLLs', 
          'c:\\Python311\\lib', 'c:\\Python311', 'c:\\Python311\\lib\\site-packages', 
          'C:/doit/mymod']
          ```
      - set 명령어를 사용해 PYTHONPATH 환경 변수에 모듈의 경로 추가
        - ```set PYTHONPATH=C:\doit\mymod```
- 패키지
  - 파이썬 모듈을 계층적(디렉터리 구조)으로 관리하기 위함
  - 모듈 이름이 A.B인 경우에 A는 패키지 이름이고, B는 A 패키지의 B모듈
    - ```
      game/
          __init__.py
          sound/
              __init__.py
              echo.py
              wav.py
          graphic/
              __init__.py
              screen.py
              render.py
          play/
              __init__.py
              run.py
              test.py
      ```
    - ```python
      # render.py
      from game.sound.echo import echo_test
      from ..sound.echo import echo_test
      
      echo_test()
      ```
    - ```python
      import game.sound.echo
      game.sound.echo.echo_test() # echo
      
      from game.sound import echo
      echo.echo_test() # echo
      
      from game.sound.echo import echo_test
      echo_test() # echo
      
      # __init__.py 파일에 __all__ 변수를 설정해줘야 함
      from game.sound import *
      echo.echo_test() # __all__ = ['echo'] 가 없으면 에러.

      # game 디렉터리의 __init__.py에 정의한 것만 참조할 수 있음
      import game
      game.sound.echo.echo_test() # 에러.
      
      # 도트 연산자(.)를 사용해서 import할 때 마지막 항목은 모듈 또는 패키지
      import game.sound.echo.echo_test # 에러. 함수이기 때문에 안됨
      ```
  - ```__init__.py```의 용도
    - 해당 디렉터리가 패키지의 일부임을 알려주는 역할을 함
    - python3.3 버전부터는 ```__init__.py``` 파일이 없어도 패키지로 인식한다
- 예외 처리
  - try, finally문
    - ```python
      try:
          f = open('foo.txt', 'w')
          4 / 0
      except ZeroDivisionError as e:
          print(e)
      except Exception as e:
          pass
      finally: # 중간에 오류가 발생하더라도 무조건 실행
          f.close()
      ```
  - try, else문
    - ```python
      try:
          age=int(input('나이를 입력하세요: '))
      except:
          print('입력이 정확하지 않습니다.')
      else: # 오류가 없을 경우에만 수행된다.
          if age <= 18:
              print('미성년자는 출입금지입니다.')
          else:
              print('환영합니다.')
      ```
  - 예외 만들기
    - ```python
      class MyError(Exception):
          # 오류 메시지를 출력하기 위한 메소드
          def __str__(self):
              return "This is a MyError"
      raise MyError()
      ```

# 유용한 함수들

- 내장 함수
  - abs()
    - 절대값을 리턴
    - ```python
      abs(-3) # 3
      abs(-1.2) # 1.2
      ```
  - round()
    - 숫자를 입력받아 반올림하여 리턴
    - ```python
      round(5.678, 2) # 5.68 (소수점 2자리까지만 반올림하여 표시)
      round(4.6) # 5
      ```
  - sum(), max(), min() 
    - 반복 가능한(iterable) 데이터를 입력받아 합, 최대값, 최소값을 리턴
    - ```python
      sum([1, 2, 3]) # 6
      max([1, 2, 3]) # 3
      min([1, 2, 3]) # 1
      max("python")  # 'y'
      min("python")  # 'h'
      ```
  - divmod(a, b), pow(a, b)
    - divmod()는 a를 b로 나눈 몫과 나머지를 튜플로, pow()는 제곱값을 리턴하는 함수
    - ```python
      divmod(7, 3) # (2, 1)
      7 // 3 # 2
      7 % 3  # 1
      
      pow(2, 4) # 16
      pow(3, 3) # 27
      ```
  - hex(), oct()
    - 정수를 입력받아 16진수, 8진수 문자열로 리턴
    - ```python
      hex(234) # '0xea'
      hex(3) # '0x3'
      oct(34) # '0o42'
      oct(12345) # '0o30071'
      ```
  - all()
    - 반복 가능한(iterable) 데이터의 요소가 모두 참이면 True, 아니면 Fasle 반환
    - ```python
      all([1, 2])  # True
      all([1, 2, 0]) # False
      all([]) # True (입력 인수가 빈 값은 경우. 참)
      ```
  - any()
    - 반복 가능한(iterable) 데이터의 요소중 하나라도 참이면 True, 아니면 Fasle 반환
    - ```python
      all([1, 2, 0])  # True
      all(["", 0]) # False
      all([]) # False (입력 인수가 빈 값은 경우. 거짓)
      ``` 
  - id()
    - 객체를 입력받아 객체의 고유 주소 값(레퍼런스)을 리턴
    - ```python
      id(3) # 135072304
      id(4) # 245072292
      
      a = 3
      b = a
      id(a) # 135072304
      id(b) # 135072304
      ```
  - map(func, iterable)
    - 반복 가능한(iterable) 데이터의 각 요소에 함수(func)를 적용한 결과를 리턴
    - ```python
      def two_times(x): 
          return x*2
      
      list(map(two_times, [1, 2, 3, 4])) # [2, 4, 6, 8]
      list(map(lambda x: x*2, [1, 2, 3, 4])) # [2, 4, 6, 8]
      ```
  - filter(func, iterable)
    - 반복 가능한(iterable) 데이터로 함수(func)를 호출했을 때, 반환 값이 참인 것만 묶어서(걸러 내서) 리턴
    - ```python
      def positive(x):
          return x > 0

      list(filter(positive, [1, -3, 2, 0, -5, 6])) # [1, 2, 6]
      list(filter(lambda x: x>0, [1, -3, 2, 0, -5, 6])) # [1, 2, 6]
      ```
  - enumerate()
    - 반복 가능한(iterable) 데이터를 입력받아 인덱스 값을 포함하는 enumerate 객체를 리턴
    - ```python
      for idx, name in enumerate(['body', 'foo', 'bar']):
          print(idx, name, end=', ') # 0 body, 1 foo, 2 bar, 
      ```
  - zip(*iterable)
    - 반복 가능한(iterable) 데이터의 다발을 동일한 개수로 이루어진 데이터로 묶어서 리턴
    - ```python
      list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)]
      list(zip("abc", "def")) # [('a', 'd'), ('b', 'e'), ('c', 'f')]
      ```
  - isinstance(object, class)
    - 객체(object)가 해당 클래스(class)의 인스턴스(instance)이면 True 아니면 False 반환
    - ```python
      a = Person()
      b = 3
      isinstance(a, Person) # True
      isinstance(b, Person) # False
      ```
  - sorted()
    - 반복 가능한(iterable) 데이터를 정렬한 후 그 결과를 리스트로 리턴
    - ```python
      sorted([3, 1, 2]) # [1, 2, 3]
      sorted("zero") # ['e', 'o', 'r', 'z']
      ```
  - type()
    - 입력값의 자료형이 무엇인지 알려 주는 함수
    - ```python
      type("abc") # <class 'str'>
      type([ ]) # <class 'list'>
      type(open("test", 'w')) # <class '_io.TextIOWrapper'>
      ```
  - input()
    - 사용자 입력을 문자열로 받는 함수
    - ```python
      a = input()
      b = input("내용을 입력하시오: ")
      ```
  - chr(), ord()
    - chr()는 유니코드 숫자값을 입력받아 문자를 생성 , ord()는 그 반대
    - ```python
      chr(97)    # 'a'
      chr(44032) # '가'
      ord('a') # 97
      ord('가') # 44032
      ```
  - dir()
    - 해당 객체가 사용가능한 함수와 변수를 보여줌
    - ```python
      dir([1, 2, 3]) # ['append', 'insert', 'pop',...]
      dir({'1':'a'}) # ['clear', 'items', 'keys',...]
      ```
  - eval()
    - 문자열로 구성된 표현식을 입력으로 받아 해당 문자열을 실행한 결괏값을 리턴
    - ```python
      eval('1+2') # 3
      eval("'hi' + 'a'") # 'hia'
      eval('divmod(4, 3)') # (1, 1)
      ```
- 표준 라이브러리
  - 파이썬을 설치할 때 자동으로 컴퓨터에 설치 (sys, re 모듈 등)
  - datetime
    - 년, 월, 일로 날짜를 표현할 때 사용하는 모듈
    - ```python
      import datatime
      
      day1 = datetime.date(2019, 12, 14)
      day2 = datetime.date(2021, 6, 5)
      Dday = day2 - day1 
      Dday.days # 539
      Dday.weekday() # 5 (0~6, 월요일~일요일)
      Dday.isoweekday() # 6 (1~7, 월요일~일요일)
      ```
  - time
    - 시간과 관련된 모듈
    - ```python
      import time
      
      # UTC(Universal Time Coordinated 협정 세계 표준시)를 사용
      time.time() # 988458015.73417199 (1970/1/1 00:00:00를 기준으로 지난 시간을 초 단위로 돌려줌)
      time.localtime(time.time()) # time.struct_time(tm_year=2013, tm_mon=5, tm_mday=21, tm_hour=16, ...)
      time.asctime(time.localtime(time.time())) # 'Sat Apr 28 20:50:20 2001'
      time.ctime() # 'Sat Apr 28 20:56:31 2001'
      time.strftime('%x', time.localtime(time.time())) # '05/01/01'
      time.strftime('%c', time.localtime(time.time())) # '05/01/01 17:22:21'
      
      time.sleep(1) # 초 단위로 쓰레드에 sleep을 걸음
      ```
  - math
    - 수학 관련 모듈
    - ```python
      import math
      
      # 최대공약수(gcd, greatest common divisor), 파이썬 3.5부터 사용 가능
      math.gcd(60, 100, 80) # 20
      # 최소공배수(lcm, least common multiple), 파이썬 3.9부터 사용 가능
      math.lcm(15, 25) # 75
      ```
  - random
    - 난수(규칙이 없는 임의의 수) 발생 모듈
    - ```python
      import random
      
      # 0.0에서 1.0 사이의 실수
      random.random() # 0.5384
      # 1에서 10 사이의 정수
      random.randint(1, 10) # 6
      # 입력으로 받은 리스트에서 무작위로 하나를 선택
      random.choice([1,2,3,4,5]) # 2
      # 리스트 요소를 무작위로 n개 선택하여 섞음
      random.sample([1,2,3,4,5], 4) # [3,5,1,2]
      ```
  - itertools
    - 반복 가능한(iterable) 데이터 관련 모듈
    - ```python
      import itertools
      
      students = ['한민서', '황지민', '이광수']
      snacks = ['사탕', '초콜릿']
      list(zip(students, snacks)) # [('한민서', '사탕'), ('황지민', '초콜릿')]
      
      # zip에선 안되는, 요소의 개수가 서로 다를 경우 초기값 설정 가능
      list(itertools.zip_longest(students, snacks, fillvalue='새우깡')) # [('한민서', '사탕'), ('황지민', '초콜릿'), ('이광수', '새우깡')]
      # 요소 n개를 선택한 순열(permutations)을 iterator로 리턴
      list(itertools.permutations(['1','2','3'], 2)) # [('1','2'),('1','3'),('2','1'),('2','3'),('3','1'),('3','2')]
      # 요소 n개를 선택한 조합(combinations)을 iterator로 리턴
      list(itertools.combinations(['1','2','3'], 2)) # [('1','2'),('1','3'),('2','3')]
      # iterator의 개수만 세려면 len() 함수 이용
      len(list(itertools.combinations(range(1, 46), 6))) # 8145060
      # 같은 숫자의 중복을 허용하는 조합(combinations)
      len(list(itertools.combinations_with_replacement(range(1, 46), 6))) # 15890700
      ```
  - functools
    - 반복 가능한(iterable) 데이터 관련 모듈
    - ```python
      import functools
      
      # 요소에 차례대로(왼쪽에서 오른쪽으로) 누적 적용하여 하나의 값으로 만드는 함수
      data = [1, 2, 3, 4, 5]
      functools.reduce(lambda x,y: x+y, data) # 15 (sum값 계산)
      functools.reduce(lambda x,y: x if x>y else y, data) # 5 (max값 계산)
      ```
  - operator
    - 다양한 기준으로 정렬할 수 있도록 도와주는 모듈
    - ```python
      import operator
      
      students1 = [("jane" 22,'A'),("dave",32,'B'),("sally",17,'B')]
      students2 = [{"name":"jane","age":22,"grade": 'A'},
                {"name":"dave","age":32,"grade":'B'},
                {"name": "sally","age":17,"grade":'B'}]
      # 나이 순서대로 정렬 (오름차순)
      sorted(students1, key=operator.itemgetter(1)) # [('sally',17,'B'),('jane',22,'A'),('dave',32,'B')]
      sorted(students2, key=operator.itemgetter('age')) # [('sally',17,'B'),('jane',22,'A'),('dave',32,'B')]
      ```
  - shutil
    - 파일을 복사(copy)하거나 이동(move)할 때 사용하는 모듈
    - ```python
      import shutil

      shutil.copy("c:/doit/a.txt", "c:/temp/a.txt.bak") # 복사
      shutil.move("c:/doit/a.txt", "c:/temp/a.txt") # 이동
      ```
  - glob
    - 디렉터리 안의 파일들을 읽어주는 모듈
    - ```python
      import glob
      
      # 디렉터리 안의 파일들을 읽어서 리턴
      glob.glob.("C:/doit/mark*") # ['c:/doit\\marks1.py', 'c:/doit\\marks2.py', 'c:/doit\\marks3.py']
      ```
  - pickle
    - 객체의 형태를 그대로 유지하면서 파일에 저장하고 불러올 수 있게 하는 모듈
    - ```python
      import pickle
      data = {1: 'python', 2: 'you need'}
      with open("test.txt", 'wb') as f:
        pickle.dump(data, f)
      with open("test.txt", 'rb') as f:
        data = pickle.load(f)
      ```
  - os
    - 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈
    - ```python
      import os
      
      # 현재 시스템의 환경 변수 값
      os.environ # environ({'PROGRAMFILES': 'C:\\Program Files', 'APPDATA': ...})
      # PATH 환경변수 
      os.environ['PATH'] # 'C:\\ProgramData\\Java\\javapath;...
      # 현재 디렉터리 위치를 변경
      os.chdir("C:\WINDOWS")
      # 현재 자신의 디렉터리 위치를 리턴
      os.getcwd() # 'C:\WINDOWS'
      # 시스템 명령어 호출하기 
      os.system("dir") # 시스템 명령어 dir을 실행
      # 시스템 명령어를 실행한 결과값을 읽기 모드 형태의 파일 객체로 리턴
      f = os.popen("dir")
      f.read()
      # 디렉터리를 생성 및 삭제
      os.mkdir("C:\TestDir")
      os.rmdir("C:\TestDir") # (디렉토리가 비어있어야 가능)
      # 파일 이름 변경
      os.rename(src, dst) # src파일을 dst라는 이름으로 바꿈
      ```
  - zipfile
    - 여러 개의 파일을 zip 형식으로 합치거나 이를 해제할 때 사용하는 모듈
    - ```python
      import zipfile
      
      # 파일 합치기 (a.txt, b.txt)
      with zipfile.ZipFile('Test.zip', 'w') as f:
          f.write('a.txt')
          f.write('b.txt')
      # 모든 파일 해제하기
      with zipfile.ZipFile('Test.zip') as f:
          f.extractall()
      # 특정 파일 해제하기
      with zipfile.ZipFile('Test.zip') as f:
          f.extract('a.txt') 
      
      # 파일을 압축하여 묶고 싶은 경우
        # ZIP_STORED - 압축하지 않고 파일을 Zip으로만 묶는다. 속도가 빠르다.
        # ZIP_DEFLATED - 일반적인 ZIP 압축으로 속도가 빠르고 압축률은 낮다. (호환성이 좋다.)
        # ZIP_BZIP2 - bzip2 압축으로 압축률이 높고 속도가 느리다.
        # ZIP_LZMA - lzma 압축으로 압축률이 높고 속도가 느리다. (7zip과 동일한 알고리즘으로 알려져 있다.)
        # compressionlevel은 압축 수준으로, 1은 속도가 가장 빠르고 압축률이 낮고, 9는 속도는 가장 느리지만 최대 압축
      with zipfile.ZipFile('CTest.zip', 'w',
        compression=zipfile.ZIP_LZMA, compresslevel=9) as f:
          f.write('a.txt')
          f.write('b.txt')
      ```
  - threading
    - 쓰레드를 구현한 모듈
    - ```python
      import time
      import threading

      def test_method():
          for i in range(5):
              time.sleep(1)
              print("working:%s\n" % i)

      print("Start")

      threads = []
      for i in range(5):
          threads.append(threading.Thread(target=test_method))

      for t in threads:
          t.start()

      for t in threads:
          t.join()  # join으로 스레드가 종료될때까지 기다린다

      print("End")
      ```
  - tempfile
    - 파일을 임시로 만들어서 사용할 때 유용한 모듈
    - ```python
      import tempfile
      
      # 중복되지 않는 임시 파일의 이름을 무작위로 만듬
      filename = tempfile.mkstemp() # 'C:\WINDOWS\TEMP\~-275151-0'
      # 임시 저장 공간으로 사용할 파일 객체를 리턴, 바이너리 쓰기 모드(wb)
      f = tempfile.TemporaryFile()
      f.close() # close가 호출되면 자동으로 삭제됨
      ```
  - traceback
    - 실행 중 발생한 오류를 추적하고자 할 때 사용하는 모듈
    - ```python
      import traceback
      
      def a():
          return 1/0
      def b():
          a()
      def main():
          try:
              b()
          except:
              print("오류가 발생했습니다.")
              print(traceback.format_exc()) # 오류 추적 결과를 문자열로 리턴
      main()
      ```
      ```
      오류가 발생했습니다.
      Traceback (most recent call last):
        File "c:\doit\traceback_sample.py", line 14, in main
          b()
        File "c:\doit\traceback_sample.py", line 9, in b
          a()
        File "c:\doit\traceback_sample.py", line 5, in a
          return 1/0
      ZeroDivisionError: division by zero
      ```
  - json
    - JSON 데이터를 쉽게 처리하고자 사용하는 모듈
    - ```python
      import json
      
      info = {'name': '홍길동', 'birth': '0525', 'age': 30}
      with open('info.json', 'w') as f:
          json.dumps(info, f, indent=4, ensure_ascii=False) # ensure_ascii=False는 한글 문자열이 아스키 형태로 변경되는 것을 방지

      with open('info.json', 'r') as f:
          data = json.load(f)
      type(data)  # <class 'dict'>
      print(data) # {'name': '홍길동', 'birth': '0525', 'age': 30}
      ```
      ```
      [myinfo.json]
      {
          "name": "홍길동",
          "birth": "0525",
          "age": 30
      }
      ```
  - urllib
    - url을 읽고 분석할 때 사용하는 모듈
    - ```python
      import urllib.request
      
      # wikidocks page의 리소스 내용을 파일로 저장
      resource = 'https://wikidocs.net/12'
      with urllib.request.urlopen(resource) as s:
          with open('wikidocs_12.html', 'wb') as f:
              f.write(s.read())
      ```
  - webbrowser
    - 시스템 브라우저를 호출할 때 사용하는 모듈
    - ```python
      import webbrowser
      
      # 해당 사이트를 새 창으로 열기
      webbrowser.open_new('http://python.org')
      # 이미 열린 브라우저로 원하는 사이트를 열기
      webbrowser.open('http://python.org')
      ```
- 외부 라이브러리
  - PyPI(Python Package Index)는 100,000건 이상의 파이썬 패키지가 모인 저장 공간
  - pip를 이용하여 외부 모듈이나 패키지를 설치할 수 있음
    - ```pip install SomePackage==1.0.4 ```
    - ```
      pip list
        
      Package                  Version
      ------------------------ --------
      amqp                     2.1.4
      anyjson                  0.3.3
      ...
      ```

# 파이썬과 유니코드

- 인코딩
  - 파이썬 3버전부터 모든 문자열은 유니코드(Unicode)로 처리
  - 유니코드 문자열을 바이트 문자열로 바꾸기
    - ```python
      a = "Life is too short"
      b = a.encode('utf-8') # b'Life is too short' (utf-8는 인코딩 방식)
      type(b)  # <class 'bytes'>
      
      a = "한글"
      a.encode("ascii")  # 에러. 한글은 지원 안함 (영문자, 숫자만)
      a.encode('euc-kr') # b'\xc7\xd1\xb1\xdb'
      a.encode('utf-8')  # b'\xed\x95\x9c\xea\xb8\x80'
      ```
  - 입출력과 인코딩
    - 파일을 읽거나 네트워크를 통해 데이터를 주고받을 때 추천하는 방법
      1. 입력으로 받은 바이트 문자열은 가능한 한 가장 빨리 유니코드 문자열로 디코딩할 것
      2. 유니코드 문자열만 함수나 클래스 등에서 사용할 것
      3. 입력에 대한 결과를 전송하는 마지막 부분에서만 유니코드 문자열을 바이트 문자열로 인코딩해서 반환할 것
      - ```python
        # 1. euc-kr로 작성된 파일 읽기 (encoding 기본값은 utf-8)
        with open('euc_kr.txt', encoding='euc-kr') as f:
            data = f.read()  # 유니코드 문자열 

        # 2. unicode 문자열로 프로그램 수행하기
        data = data + "\n" + "추가 문자열"

        # 3. euc-kr로 수정된 문자열 저장하기
        with open('euc_kr.txt', encoding='euc-kr', mode='w') as f:
            f.write(data)
        ```
  - 소스 코드의 인코딩
    - 소스 코드도 파일이므로 인코딩 타입이 필요, 소스 코드 가장 위에 인코딩 방식을 명시
      - ```# -*- coding: euc-kr -*- (파이썬 3.0부터는 utf-8이 기본값)```
- 디코딩
  - 바이트 문자열을 유니코드 문자열로 바꾸기
    - ```python
      a = '한글'
      b = a.encode('euc-kr')
      b.decode('euc-kr') # '한글'
      ```

# 클로저와 데코레이터

- 클로저(closure)
  - 내부 함수(inner function)을 구현하고 그 내부 함수를 리턴하는 함수를 말한다
    - ```python
      # mul()를 구현한 클래스
      class Mul:
          def __init__(self, m):
              self.m = m
          def __call__(self, n):
              return self.m * n

      # 외부 함수(mul()) 안에 내부 함수(wrapper())를 구현
      # mul() 함수 호출 시, 인수로 받은 m값을 wrapper() 함수에 저장하여 리턴
      # 클래스가 특정한 값을 설정하여 객체를 만드는 과정과 매우 비슷
      def mul(m):
          def wrapper(n):
              return m * n
          return wrapper
      
      if __name__ == "__main__":
          mul_class = Mul(3)
          mul_closure = mul(3)
          print(mul_class(10))  # 30 출력
          print(mul_closure(10))  # 30 출력
      ```
- 데코레이터(decorator)
  - 수정하지 않고도 함수에 특정 동작을 추가하거나 작동 방식을 바꾸는 방법을 말한다
  - 파이썬 데코레이터는 ('@'+데코레이터 함수명)을 이용한 어노테이션으로 사용할 수 있음
    - ```python
      import time

      # 파이썬은 함수도 객체이므로 함수 자체를 인수로 전달할 수 있음
      def elapsed(original_func):
          def wrapper(*args, **kwargs):
              start = time.time()
              result = original_func(*args, **kwargs)
              end = time.time()
              print("함수 수행시간: %f 초" % (end - start))
              return result
          return wrapper

      def myfunc1():
          print("함수가 실행됩니다.")
      decorated_myfunc = elapsed(myfunc1)
      decorated_myfunc()
      
      @elapsed
      def myfunc2(msg):
          print("'%s'을 출력합니다." % msg) 
      myfunc2("You need python")
      
      ```

# 이터레이터와 제너레이터

- 이터레이터(iterator)
  - iterator는 next() 함수 호출 시 계속 다음 값을 리턴하는 객체
  - 반복 가능한(iterable) 객체는 iter() 함수를 이용하여 만들 수 있다
  - 클래스에 __iter__와 __next__ 두 개의 메소드를 구현하면 만들 수 있다
    - ```python
      a = [1, 2, 3]
      ia = iter(a)
      type(ia) # <class 'list_iterator'>
      next(ia) # 1
      next(ia) # 2
      next(ia) # 3
      next(ia) # 에러. 리턴할 값이 없음(StopIteration)
      
      # next()로 그 값을 한 번 읽으면 그 값을 다시는 읽을 수 없다
      for i in iter(a):
          print(i, end=' ') # 1 2 3
      ```
    - ```python
      class MyItertor:
          def __init__(self, data):
              self.data = data
              self.position = 0
      
          # 이터레이터 객체를 리턴하는 메소드
          def __iter__(self):
              return self
      
          # next() 함수 호출 시 수행
          def __next__(self):
              if self.position >= len(self.data):
                  raise StopIteration
              result = self.data[self.position]
              self.position += 1
              return result

      if __name__ == "__main__":
          i = MyItertor([1, 2, 3])
          for item in i:
              print(item)
      ```
- 제네레이터(generator)
  - 차례대로 결과를 리턴하고자 return 대신 yield 키워드를 사용
  - 제너레이터 객체는 제너레이터 함수를 호출하여 만들 수 있다
  - 값을 리턴하되 현재 상태를 그대로 기억하기 때문에, 제너레이터를 코루틴(coroutine)이라 부르기도 함
    - ```python
      def mygen():
          for i in range(1, 1000):
              result = i * i
              yield result
      gen = mygen()
      type(gen) # <class 'generator'>
      
      # 튜플 표현식으로 좀 더 간단하게 만들 수 있음
      # 제너레이터 표현식(generator expression)이라고 부름
      gen = (i * i for i in range(1, 1000))
      next(gen) # 1
      next(gen) # 4
      next(gen) # 9
      ```
  - 파이썬은 파일 객체를 제너레이터로 만들어 처리 
    - 파일을 모두 읽어서 메모리에 올려 놓은 후에 처리하는 것이 아님
    - 한 줄씩 순서대로 처리하기 때문에 작은 메모리로도 대용량 파일 처리 가능
      - ```python
        with open('bigdata.txt') as f:
            for line in f:
                # process the line
        ```
  - 느긋한 계산법(lazy evaluation)
    - 모든 함수를 한꺼번에 실행하는 것이 아니라 필요할 때만 실행하는 방식
      - ```python
        import time

        def longtime_job():
            print("job", end=' ')
            time.sleep(1)
            return "'done'"

        # 리스트에 결과값을 담고 이를 이터레이터로 변경
        # 리스트를 만들 때 이미 5개의 함수를 모두 실행
        list_job = iter([longtime_job() for i in range(5)])
        print(next(list_job)) # job job job job job 'done'
        
        # 제너레이터 표현식으로 생성
        list_job = (longtime_job() for i in range(5))
        print(next(list_job)) # job 'done'
        ```

# 타입 어노테이션

- 동적 언어, 정적 언어
  - 파이썬은 프로그램 실행 중에 변수의 타입을 동적으로 바꿀 수 있음 (타입 체크를 위한 코드가 필요 없다)
  - 동적 프로그래밍 언어(dynamic programming language)
    - ```python
      a = 1
      type(a) # <class 'int'>
      a = "1"
      type(a) # <class 'str'>
      ```
  - 자바는 프로그램 실행 중에 변수의 타입을 동적으로 바꿀 수 없음
  - 정적 프로그래밍 언어(static programming language)
    - ```java
      int a = 1; // a변수를 int형으로 지정
      a = "a";   // 컴파일 에러.
      ```
- 타입 어노테이션(type annotation)
  - 파이썬은 3.5 버전부터 지원, 단순히 타입에 대한 힌트를 알려주는 정도
    - ```python
      num: int = 1
      type(a) # <class 'int'>
      
      def add(a: int, b: int) -> int: 
          return a+b
      ```
  - 어노테이션 타입
    - 정수: int
    - 문자열: str
    - 리스트: list
    - 튜플은: tuple
    - 딕셔너리: dict
    - 집합: set
    - 불: bool
  - 외부 라이브러리 mypy
    - 어노테이션 타입을 체크해서 오류를 발생시킴
    - ```python
      # sample.py
      def add(a: int, b: int) -> int: 
          return a + b

      result = add(3, 3.4)
      print(result)
      ```
    - ```
      pip install mypy
      mypy sample.py  -> 에러.
      
      sample.py:5: error: Argument 2 to "add" has incompatible type "float"; expected "int"
      Found 1 error in 1 file (checked 1 source file)
      ```

# 정규 표현식

- 정규 표현식(regular expressions)
  - 복잡한 문자열을 처리할 때 사용하는 기법
  - 정규식의 필요성
    - ```
      문제) 주민등록번호를 포함하고 있는 텍스트가 있다.
        이 텍스트에 포함된 모든 주민등록번호의 뒷자리를 * 문자로 변경해 보자.
      ```
    - 정규 표현식을 사용하지 않을 경우
      - ```
         1. 전체 텍스트를 공백 문자로 나눈다(split)
         2. 나뉜 단어가 주민등록번호 형식인지 조사한다
         3. 단어가 주민등록번호 형식이라면 뒷자리를 *로 변환한다
         4. 나뉜 단어를 다시 조립한다
      - ```python
        data = """
          park 800905-1049118
          kim  700905-1059119
          """

        result = []
        for line in data.split("\n"):
            word_result = []
            for word in line.split(" "):
                if len(word) == 14 and word[:6].isdigit() and word[7:].isdigit():
                    word = word[:6] + "-" + "*******"
                word_result.append(word)
            result.append(" ".join(word_result))
        print("\n".join(result))
        ```
    - 정규 표현식을 사용할 경우
      - ```python
        import re 

        data = """
          park 800905-1049118
          kim  700905-1059119
          """

        pat = re.compile("(\d{6})[-]\d{7}")
        print(pat.sub("\g<1>-*******", data))
        ```
- 정규 표현식의 기초
  - 메타 문자(meta charactors)
    - 정규 표현식에서 특별한 용도로 사용하는 문자를 말함
    - ``` . ^ $ * + ? { } [ ] \ | ( ) ```
  - 문자 클래스(```[ ]```) 
    - ```[ ]``` 사이의 문자들과 매치 라는 의미
    - ```^``` 메타 문자를 사용할 경우에는 반대(not)라는 의미
    - 하이픈(-)을 사용하면 두 문자 사이의 범위(From - To)
      - ```
        정규 표현식: [abc]
        ex) "a"는 정규식과 일치하는 문자인 "a"가 있으므로 매치됨
        ex) "before"는 정규식과 일치하는 문자인 "b"가 있으므로 매치됨
        ex) "dude"는 정규식과 일치하는 문자인 a, b, c 중 어느 하나도 포함하고 있지 않으므로 매치 실패
        ```
      - ```
        [0-9] : 숫자
        [a-zA-Z] - 알파벳 모두
        \d - 숫자와 매치, [0-9]와 동일한 표현식
        \D - 숫자가 아닌 것과 매치, [^0-9]와 동일한 표현식
        \s - whitespace 문자와 매치, [ \t\n\r\f\v]와 동일한 표현 (빈 칸은 공백문자(space))
        \S - whitespace 문자가 아닌 것과 매치, [^ \t\n\r\f\v]와 동일한 표현식
        \w - 문자+숫자(alphanumeric)와 매치, [a-zA-Z0-9_]와 동일한 표현식
        \W - 문자+숫자(alphanumeric)가 아닌 문자와 매치, [^a-zA-Z0-9_]와 동일한 표현식
        ```
  - 점(dot, ```.```)
    - \n을 제외한 모든 문자와 매치됨을 의미
      - ```
        정규 표현식: a.b
        ex) "aab"는 가운데 문자 "a"가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치됨
        ex) "a0b"는 가운데 문자 "0"가 모든 문자를 의미하는 .과 일치하므로 정규식과 매치됨
        ex) "ab"는 "a"문자와 "b"문자 사이에 어떤 문자라도 하나는있어야 하는 이 정규식과 일치하지 않으므로 매치 실패
        ```
  - 반복(```{m,n}, *, +, ?```)
    - 바로 앞 문자가 m~n번 반복될 수 있다는 의미
    - m 또는 n을 생략 가능 (m의 초기값은 0)
    - ```*```: ```{0,}``` (0~n번 반복될 수 있다는 의미)
    - ```+```: ```{1,}``` (1~n번 반복될 수 있다는 의미)
    - ```?```: ```{0,1}```(0~1번 반복될 수 있다는 의미)
      - ```
        정규 표현식: ca{2}t
        ex) "cat"는 "a"가 1번 반복되어 매치 실패
        ex) "caat"는 "a"가 2번 반복되어 매치됨
        
        정규 표현식: ca{2,3}t
        ex) "caat"는 "a"가 2번 반복되어 매치됨
        ex) "caaat"는 "a"가 3번 반복되어 매치됨
        
        정규 표현식: ca*t
        ex) "ct"는 "a"가 0번 반복되어 매치됨
        ex) "cat"는 "a"가 1번 반복되어 매치됨
        
        정규 표현식: ca+t
        ex) "ct"는 "a"가 0번 반복되어 매치 실패
        ex) "cat"는 "a"가 1번 반복되어 매치됨
        
        정규 표현식: ab?c
        ex) "ac"는 "b"가 0번 사용되어 매치됨
        ex) "abc"는 "b"가 1번 사용되어 매치됨
        ```
- re 모듈
  - 정규 표현식을 지원하는 파이썬 모듈로, 자동으로 설치되는 표준 라이브러리
    - 정규식 객체 생성
      - ```python
        import re
        p = re.compile('ab*') # 컴파일된 패턴 객체라 부름
        ```
  - 정규식의 문자열 검색 함수
    - match()
      - 문자열의 처음부터 정규식과 매치되는지 조사
      - 정규식과 매치될 때는 match 객체를 리턴, 매치되지 않을 때는 None을 리턴
        - ```python
          p = re.compile('[a-z]+')
          
          m = p.match("python")
          print(m) # <re.Match object; span=(0, 6), match='python'>
          m = p.match("3 python")
          print(m) # None
          ```
    - search()
      - 문자열 전체를 검색하여 정규식과 매치되는지 조사
      - 정규식과 매치될 때는 match 객체를 리턴, 매치되지 않을 때는 None을 리턴
        - ```python
          p = re.compile('[a-z]+')
          
          m = p.search("python")
          print(m) # <re.Match object; span=(0, 6), match='python'>
          m = p.search("3 python")
          print(m) # <re.Match object; span=(2, 8), match='python'> (문자열 전체를 검색)
          ```
    - findall()
      - 정규식과 매치되는 모든 문자열(substring)을 리스트(list)로 리턴
        - ```python
          p = re.compile('[a-z]+')
          
          result = p.findall("life is too short")
          print(result) # ['life', 'is', 'too', 'short']
          ```
    - finditer()
      - 정규식과 매치되는 모든 문자열(substring)을 반복 가능한 객체(iterator object)로 리턴
      - 반복 가능한 객체가 포함하는 각각의 요소는 match 객체
        - ```python
          p = re.compile('[a-z]+')
          
          result = p.finditer("life is too short")
          print(result) # <callable_iterator object at 0x01F5E390>
          for r in result:
              print(r)
          # <re.Match object; span=(0, 4), match='life'>
          # <re.Match object; span=(5, 7), match='is'>
          # <re.Match object; span=(8, 11), match='too'>
          # <re.Match object; span=(12, 17), match='short'>
          ```
  - match 객체의 함수
    - group()
      - 매치된 문자열을 리턴
        - ```python
          m = p.match("python")
          m.group() # 'python'
          ```
    - start(), end()
      - 매치된 문자열의 시작 위치, 끝 위치를 리턴
        - ```python
          m = p.match("python")
          m.start() # 0
          m.end()   # 6
          ```
    - span()
      - 매치된 문자열의 (시작, 끝)에 해당하는 튜플을 리턴
        - ```python
          m = p.match("python")
          m.span() # (0, 6)
          ```
  - 컴파일된 패턴 객체로 match 함수 사용하기
    - ```python
      # 아래의 코드를 축약한 형태
      m = re.match('[a-z]+', "python")
      
      #p = re.compile('[a-z]+')
      #m = p.match("python")
      ```
  - 정규식 컴파일 옵션
    - DOTALL, S
      - ```.```문자가 \n를 포함하여 모든 문자와 매치할 수 있도록 함
      - 여러 줄로 이루어진 문자열에서 줄바꿈 문자에 상관없이 검색할 때 많이 사용
        - ```python
          p = re.compile('a.b', re.DOTALL) # (re.S)
          p.match('a\nb') # <re.Match object; span=(0, 3), match='a\nb'>
          ```
    - IGNORECASE, I
      - 대소문자 구별 없이 매치를 수행할 때 사용
        - ```python
          p = re.compile('[a-z]+', re.IGNORECASE) # (re.I)
          p.match('Python') # <re.Match object; span=(0, 6), match='Python'>
          p.match('PYTHON') # <re.Match object; span=(0, 6), match='PYTHON'>
          ```
    - MULTILINE, M
      - ```^, $```를 문자열 전체가 아니라, 각 라인의 처음 또는 끝으로 인식시키고 싶은 경우 사용
        - ```python
          data = """python one
            life is too short
            python two
            you need python
            python three"""
          
          p = re.compile("^python\s\w+")
          p.findall(data) # ['python one']
          
          p = re.compile("^python\s\w+", re.MULTILINE) # (re.M)
          p.findall(data) # ['python one', 'python two', 'python three']
          ```
    - VERBOSE, X
      - 정규식을 주석 또는 줄 단위로 구분할 수 있게 해줌
      - 옵션을 사용하면 문자열에 사용된 whitespace는 컴파일할 때 제거
      - 줄 단위로 #기호를 사용하여 주석문을 작성 가능
        - ```python
          p = re.compile(r'&[#](0[0-7]+|[0-9]+|x[0-9a-fA-F]+);')
          p = re.compile(r"""
              &[#]                # Start of a numeric entity reference
               (
                   0[0-7]+         # Octal form
                 | [0-9]+          # Decimal form
                 | x[0-9a-fA-F]+   # Hexadecimal form
               )
               ;                   # Trailing semicolon
              """, re.VERBOSE)  # (re.X)
          ```
  - 백슬래시 문제
    - 정규식에서 사용한 `\` 문자가 문자열 자체임을 알려 주기 위해 백슬래시 2개를 사용해야 함
    - 정규식 문자열 앞에 r 문자를 삽입하면 이 정규식은 Raw String 규칙을 적용하겠다는 의미
      - ```python
        p = re.compile('\\\\section')
        
        # 위 정규식과 동일
        p = re.compile(r'\\section')
        ```
  - 문자열 소비가 없는(zerowidth assertions) 메타 문자
    - ```|```
      - or와 동일한 의미로, A 또는 B라는 의미
        - ```python
          p = re.compile('Crow|Servo')
          p.match('CrowHello') # <re.Match object; span=(0, 4), match='Crow'>
          ```
    - ```^, $```
      - 문자열 전체의 맨 처음 또는 끝과 일치함을 의미
      - MULTILINE 옵션을 사용하면 각 라인의 문자열과 매치
        - ```python
          re.search('^Life', 'Life is too short') # <re.Match object; span=(0, 4), match='Life'>
          re.search('^Life', 'My Life') # None
          
          re.search('short$', 'Life is too short') # <re.Match object; span=(12, 17), match='short'>
          re.search('short$', 'My Life') # None
          ```
    - ```\A, \Z```
      - 문자열 전체의 맨 처음 또는 끝과 일치함을 의미
      - MULTILINE 옵션을 사용해도 의미가 변하지 않음
    - ```\b```
      - 단어 구분자(word boundary)로 whitespace에 의해 구분됨을 의미
      - \b는 파이썬 리터럴 규칙에 BackSpace를 의미하므로 Raw string임을 표시해야 함
        - ```python
          # 앞뒤가 whitespace로 구분된 class라는 단어와 매치됨을 의미
          p = re.compile(r'\bclass\b')
          p.search('no class at all') # <re.Match object; span=(3, 8), match='class'>
          p.search('one subclass is') # None
          ```
    - ```\B```
      - ```\b```와 반대, whitespace에 의해 구분된 단어가 아닌 경우에 매치
        - ```python
          # 앞뒤가 whitespace로 구분된 class라는 단어와 매치됨을 의미
          p = re.compile(r'\Bclass\B')
          p.search('one subclass is') # None
          p.search('the declassified algorithm') # <re.Match object; span=(6, 11), match='class'>
          ```
  - 그루핑(grouping)
    - ```( )``` 메타 문자를 사용
      - ```python
        # ABC 문자열이 계속해서 반복되는지 조사
        p = re.compile('(ABC)+')
        m = p.search('ABCABCABC OK?') # <re.Match object; span=(0, 9), match='ABCABCABC'>
        m.group() # ABCABCABC
        ```
    - match 객체의 group() 함수 사용
      - 그루핑을 사용하면 group 함수를 이용해 특정 문자열만 뽑아낼 수 있음
      - 그룹이 중첩되어 있는 경우는 안쪽으로 들어갈수록 인덱스가 증가
      - group(0): 매치된 전체 문자열, group(n): n번째 그룹에 해당되는 문자열
        - ```python
          p = re.compile(r"(\w+)\s+((\d+)[-]\d+[-]\d+)")
          m = p.search("park 010-1234-1234")
          m.group(1) # park
          m.group(3) # 010
          ```
    - 그루핑한 문자열의 재참조(backreferences)
      - 재참조 메타 문자: ```\1```(첫 번째 그룹), ```\n```(n 번째 그룹)
        - ```python
          p = re.compile(r'(\b\w+)\s+\1') # (그룹) + " " + 그룹과 동일한 단어
          m = p.search('Paris in the the spring')
          m.group() # 'the the' (2개의 동일한 단어를 연속적으로 사용해야만 매치)
          ```
    - 그루핑된 문자열에 이름 붙이기
      - ```(?P<그룹명>...)```의 확장 구문을 사용
        - ```python
          p = re.compile(r"(?P<name>\w+)\s+((\d+)[-]\d+[-]\d+)")
          m = p.search("park 010-1234-1234")
          m.group("name") # park
          
          # 재참조할 때에는 (?P=그룹이름)이라는 확장 구문을 사용
          p = re.compile(r'(?P<word>\b\w+)\s+(?P=word)')
          m = p.search('Paris in the the spring')
          m.group() # 'the the'
          ```
  - 전방 탐색(lookahead assertions)
    - 긍정형 전방 탐색: ```(?=...)```
      - ```...```에 해당되는 정규식과 매치되어야 함
      - 조건이 통과되어도 문자열이 소비되지 않음 (검색에는 포함되지만 검색 결과에는 제외됨)
        - ```python
          p = re.compile(".+(?=:)")
          m = p.search("http://google.com")
          m.group() # http
          ```
    - 부정형 전방 탐색: ```(?!...)```
      - ```...```에 해당되는 정규식과 매치되지 않아야 함
      - 조건이 통과되어도 문자열이 소비되지 않음 (검색에는 포함되지만 검색 결과에는 제외됨)
        - ```python
          p = re.compile(".*[.].*$") # 파일 이름 + . + 확장자
          p = re.compile(".*[.](?!bat$|exe$).*$") # 확장자가 bat 또는 exe가 아닌 경우에만 통과
          ```
  - 문자열 바꾸기
    - sub()
      - 정규식과 매치되는 부분을 다른 문자로 바꿀 수 있음
      - 첫 번째 인수는 바꿀 문자열(replacement), 두 번째 인수는 대상 문자열, 세 번째 인수에 바꾸기 횟수 제한
        - ```python
          p = re.compile('(blue|white|red)')
          p.sub('colour', 'blue socks and red shoes') # 'colour socks and colour shoes'
          p.sub('colour', 'blue socks and red shoes', count=1) # 'colour socks and red shoes'
          ```
      - ```\g<그룹이름>```으로 정규식의 그룹 참조
        - ```python
          p = re.compile(r"(?P<name>\w+)\s+(?P<phone>(\d+)[-]\d+[-]\d+)")
          p.sub("\g<phone> \g<name>", "park 010-1234-1234") # 010-1234-1234 park
          p.sub("\g<2> \g<1>", "park 010-1234-1234") # 010-1234-1234 park (참조 번호도 가능)
          ```
      - 매개변수로 함수 넣기
        - ```python
          # match 객체(위에서 숫자에 매치되는)를 입력으로 받음
          def hexrepl(match):
              value = int(match.group())
              return hex(value)
          p = re.compile(r'\d+')
          p.sub(hexrepl, 'Call 65490 for printing.') # 'Call 0xffd2 for printing'
          ```
    - subn()
      - sub()와 동일한 기능이지만 반환 결과가 튜플로 리턴됨
      - 리턴된 튜플의 첫 번째 요소는 변경된 문자열, 두 번째 요소는 바꾸기가 발생한 횟수
        - ```python
          p = re.compile('(blue|white|red)')
          p.subn( 'colour', 'blue socks and red shoes') # ('colour socks and colour shoes', 2)
          ```
  - Non-greedy 문자 ```?```의 사용
    - 가능한 최소한의 반복을 수행하도록 도와주는 역할
    -  ```*?```, ```+?```, ```??```, ```{m,n}?```와 같이 사용가능
    - Greedy로 동작
      - ```python
        s = '<html><head><title>Title</title>'
        re.match('<.*>', s).group() # <html><head><title>Title</title>
        ```
    - Non-greedy로 동작
      - ```python
        s = '<html><head><title>Title</title>'
        re.match('<.*?>', s).group() # <html>
        ```


# 유용한 라이브러리
- heapq
  - heapq 모듈은 이진 트리(binary tree) 기반의 최소 힙(min heap) 자료구조를 제공
  - 자바의 PriorityQueue 클래스, 파이썬의 보통 리스트를 마치 최소 힙처럼 다룰 수 있도록 도와줌
  - ```python
    import heapq
    array = []
    heapq.heappush(array, 4)
    heapq.heappush(array, 1)
    heapq.heappush(array, 7)
    heapq.heappush(array, 3)
    array # [1, 3, 7, 4]
    
    heapq.heappop(array) # 1
    array # [3, 4, 7]
    
    print(heap[0])  # 1
    array # [1, 3, 7, 4]
    
    array = [4, 1, 7, 3, 8, 5]
    heapify(array) # heap으로 만들기
    array # [1, 3, 5, 4, 8, 7]
    ```
  - 튜플(tuple)를 원소로 추가하거나 삭제하면, 튜플 내에서 맨 앞에 있는 값을 기준으로 정렬됨
    - 최대 힙(max heap)으로 활용하는 방법 : (우선 순위, 값) #(-num, num)
- bisect
  - 정렬된 리스트에서 탐색 범위를 절반씩 좁혀나가며 빠르게 탐색하는 방법
  - bisect.bisect(정렬된 리스트, target)
    - bisect.bisect_right과 동일
    - 정렬된 리스트에서 target을 insert할때의 위치+1
  - bisect.bisect_left(정렬된 리스트, target)
    - 정렬된 리스트에서 target을 insert할때의 위치
  - bisect.insert()
    - bisect함수와 동일하게 작동하고, 해당 인덱스에 값을 삽입을 해준다.
  - ```python
    import bisect
    a = [1,2,3,4,5]
    c = bisect.bisect(a, 3)      # 3과 4 사이 인덱스인 3반환
    b = bisect.bisect_left(a, 3) # 2와 3 사이 인덱스인 2반환

    # 정렬된 리스트에서 특정 값이 몇번 존재하는지 확인 가능
    a = [1,2,3,3,3,4,5]
    bisect.bisect(a, 3) - bisect.bisect_left(a, 3) # 5-2=3
    ```

 




※ bisect.bisect는 bisect.bisect_right와 동일함


















