## 메모리(Memory)

### 1. 메모리
- 메모리 계층
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/e10ea47b-e14c-4d73-9853-ee23f4644a59)
  - 레지스터: CPU 안에 있는 작은 메모리, 휘발성이 있고, 기억 용량이 가장 적다
  - 캐시(cache)
    - 빠른 장치와 느린 장치에서 속도 차이에 대한 병목 현상을 줄이기 위한 메모리로 휘발성이 있고 CPU(레지스터)와 메모리 사이에 위치한다
    - 시간 지역성(temporal locality, 계속 사용하는 for문의 변수 등)와 공간 지역성(spatial locality, 배열과 같은 연속된 공간 등)를 고려하여 자주 사용하는 데이터를 기반으로 설정해야 한다
    - 캐시 매핑
      - 캐시가 히트되기 위해 캐시에 데이터를 매핑하는 방법을 의미한다
      - 직접 매핑(directed mapping)은 메모리가 1~100, 캐시가 1~10이라면 1:1~10,2:11~20...과 같이 순서를 일치시켜 매핑하여 처리가 빠르지만 충돌이 자주 발생한다
      - 연관 매핑(associative mapping)은 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하여 충돌을 적지만 모든 블록을 탐색해야 해서 속도가 느리다
      - 집합 연관 매핑(set associative mapping)은 직접 매핑과 연관 매핑을 합쳐 놓은 것으로 순서는 일치시키지만 블록으로 나눠 그 안에는 연관 매핑을 한다
    - 웹 브라우저의 캐시
      - 쿠키: 만료기한이 있는 키-값 저장소로 다른 도메인에서 요청했을 때 자동으로 전송된다
      - 세션: 만료기한이 없는 키-값 저장소로 탭 단위로 스토리지를 생성하고 탭을 닫으면 데이터가 삭제된다
      - 로컬 스토리지: 만료기한이 없는 키-값 저장소로 도메인 단위로 저장되고 브라우저를 닫아도 유지된다
    - 데이터베이스의 캐시
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/c4bd9d94-032e-4d9f-b21f-dc6a24d74701)
  - 주기억장치: RAM을 가리키고 휘발성이 있다
  - 보조기억장치: HDD, SSH를 가리키고 비휘발성이고, 속도가 느린만큼 용량이 크다
- 가상 메모리(virtual memory)
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/99e9b538-0c0e-4d6b-b6c6-4564b214ad9c)
  - 메모리 관리 기법의 하나로 실제 메모리 자원을 추상화하여 사용자에게 매우 큰 메모리로 보이게 만드는 기법이다
  - 실제 메모리상에 있는 주소를 physical address 라고 하고 최소 크기의 단위는 프레임(frame)을 사용한다
  - 가상 메모리상에 있는 주소를 logical address 라고 하고 최소 크기 단위는 페이지(page)를 사용한다
  - 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며 페이지 테이블(page table)에 가상 주소와 실제 주소가 매핑되어 있다
    - TLB(Translation Lookaside Buffer): 페이지 테이블에 있는 리스트를 보관하며 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
  - 페이지 폴트(page fault)
    - 가상 메모리(프로세스의 주소 공간)에는 존재하지만 실제 메모리에 없는 데이터에 접근할 경우 발생
    - 스와핑(swapping): 페이지 폴트가 발생하여 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 HDD의 일부분을 메모리처럼 불러와 사용하는 작업
    - 페이지 폴트 과정 
      1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩(trap)을 발생해서 운영체제에 알린다
      2. 운영체제는 CPU의 동작을 잠시 멈추고, 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인한다
      3. 가상 메모리에도 없다면 프로세스를 중단시키고 현재 물리 메모리에 비어 있는 프레임을 찾는다
      4. 빈 공간이 없다면 스와핑 시킨 후, 스와핑된 프레임에 해당 페이지를 로드하고 페이지 테이블을 최신화한다
      5. 중단되었던 CPU를 다시 시작한다
  - 쓰레싱(thrashing)
    - 메모리에 너무 많은 프로세스가 동시에 올라가서 메모리의 페이지 폴트율이 높아져 발생하는 컴퓨터의 심각한 성능 저하를 의미한다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/72b129d6-a191-4925-b2e6-042ba2dcbe6e)
      - 쓰레싱이 발생하면 CPU 이용률이 낮아지고 운영체제는 CPU의 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올리는 악순환이 발생한다
    - 해결 방법
      - 작업 세트(working set): 프로세스의 과거 사용 이력인 지역성(locality)을 통해 페이지 집합을 만들어서 미리 메모리에 로드한다. 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있다
      - PFF(Page Fault Frequency): 페이지 폴트 빈도의 상한선과 하한선을 만들어서 만약 상한선에 도달한다면 메모리 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다
- 메모리 할당
  - 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당한다
  - 메모리 공간에 연속적으로 할당할 수도 있고, 불연속적으로 할당할 수도 있으며, 현대 운영체제는 불연속 할당인 페이징 기법을 주로 사용한다
  - 용어 정리
    - 홀(hole): 할당할 수 잇는 비어 있는 메모리 공간을 의미한다
    - 내부 단편화(internal fragmentation): 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
    - 외부 단편화(external fragmentation): 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상 (100를 55,45로 나눴을 때 70의 프로그램을 들어가지 못한다)
    - 고정 분할 방식(fixed partition allocation)은 메모리를 미리 나누어 관리하는 방식이며 유연하지 않고 내부 단편화가 발생할 수 있다
    - 가변 분할 방식(variable partition allocation)은 매 시점 프로그램의 크기에 맞게 동적으로 할당하며, 내부 단편화는 없지만 외부 단편화는 존재한다
      - 최초 적합(first fit): 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당한다
      - 최적 적합(best fit): 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다
      - 최악 적합(worst fit): 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당한다
  - 할당 방법
    - 페이징(pageing)
      - 메모리를 동일한 크기의 페이지(보통 4KB)로 나누고 프로그램마다 페이지 테이블(page table)을 두어 메모리에 프로그램을 할당하는 방법
      - 홀의 크기가 균일하지 않은 문제는 없지만 주소 변환이 복잡하다
    - 세그멘테이션(segmentation)
      - 코드 영역, 데이터 영억, 스택 영역, 힙 영역 등의 의미가 있는 단위인 세그먼트(segment)로 메모리를 나누는 방법
      - 공유와 보안 측면에서는 장점을 가지지만 홀 크기가 균일하지 않은 단점이 있다
    - 페이지드 세그멘테이션(paged segmentation): 프로그램을 의미 단위인 세그먼트로 나눈 후 임의의 길이가 아닌 돌일한 크기의 페이지 단위로 나누는 방법
- 페이지 교체 알고리즘
  - 메모리가 한정되어 있기 때문에 스와핑이 발생할 경우 교체해야 하는 부분을 정하는 알고리즘
  - FIFO(First In First Out): 메모리에 가장 먼저 온 페이지를 먼저 교체하는 방법
  - LRU(Least Recently Used)
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/d699cc2e-6cb4-4dc6-828b-ca5e048c5dc6)
    - 참조가 가장 오래된 페이지를 바꾸는 방법이며 오래된 것을 파악하기 위해 페이지마다 계수기와 스택이 존재할 수 있다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/7b1f85d0-e967-4392-a0b6-ea05f63cb25b)
    - 해시 테이블과 이중 연결 리스트로 구현할 수 있고, head에 가까운 node 일수록 가장 최근에 참조된 페이지, tail 에 가까운 node 일수록 가장 오랫동안 참조되지 않는 페이지
  - NUR(Not Used Recently)
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/a508a9e5-c220-44c1-9204-8b559df20e94)
    - clock 알고리즘이라고 하며 LRU를 근사한 알고리즘이지만 페이지의 참조 시점이 가장 오래되었다는 것은 보장하지 않는다
    - 최근 참조된 것은 1로 표시하고 아닌것은 0으로 표시한 후 시계 방향으로 돌면서 0을 찾아 교체하는 방법
  - LFU(Least Frequently Used): 가장 참조 횟수가 적은 페이지를 교체하는 방법








                                               