## 프로세스와 스레드(Process and Thread)

### 1. 프로세스와 스레드
- 프로그램의 컴파일 과정
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/4d897371-1ffc-4873-b7b4-c5d0da206698)
  - 전처리: 소스 코드의 주석을 제거하고 헤더 파일을 병합하여 매크로를 치환한다
  - 컴파일러: 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다
  - 어셈블러: 컴파일된 어셈블리어는 목적 코드(object code)로 변환됩니다
  - 링커: 프로그램 내에 있는 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다
- 프로세스의 상태
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/e159cbd0-1d7f-47f4-988e-2f859689af0f)
  - 생성 상태(create): fork() 또는 exec() 함수를 통해 프로세스가 생성된 상태를 의미하며, 이때 PCB가 할당된다
  - 대기 상태(ready): CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태로, 메모리 공간이 충분하면 메모리를 할당받고 아니면 대기한다
  - 대기 중단 상태(ready suspended): 메모리 부족으로 일시 중단된 상태를 의미한다
  - 실행 상태(running): CPU 소유권과 메모리를 할당받고 명령(instruction)을 수행 중인 상태를 의미하고, 이를 CPU burst가 일어났다고 표현한다
  - 중단 상태(blocked): 인터럽트와 같은 어떤 이벤트가 발생한 이후 기다리며 프로레스가 차단된 상태를 의미한다
  - 일시 중단 상태(blocked suspended): 대기 중단 상태와 유사하고, 중단 상태에서 메모리 부족으로 일시 중단된 상태를 의미한다
- 프로세스의 메모리 구조
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/74840242-1d0e-4d19-b977-1008ad42d3f6)
  - 스택과 힙은 런타임 단계에서 메모리를 할당받는 동적 할당이며 데이터 영역과 코드 영역은 컴파일 단계에서 메모리를 할당하는 정적 할당이다
  - 스택은 지역변수, 매개변수, 실행되는 함수에서 생성된 변수의 메모리 영역이고, 힙은 동적으로 할당되는 변수의 메모리 영역이다
  - 데이터 영역은 BSS segment(Uninitialized Data)와 Data segement(Initialized Data), code/text segment로 나뉜다
    - bss segment는 전역 변수, static, const로 선언되어 있고 0으로 초기화된 변수 또는 초기화가 되어 있지 않은 변수들이 이 메모리 영역에 할당된다
    - data segment는 전역 변수, static, const로 선언되어 있고 0이 아닌 값으로 초기화된 변수가 이 메모리 영역에 할당된다
    - code/text segment는 실행 가능한 명령어(instruction)가 포함된 프로그램의 코드가 할당된다
  - segment 영역이 구분되는 이유는 code는 ROM에, bss는 RAM에, data는 ROM에 저장하고, 실행과 함께 RAM으로 불러와 사용하여 메모리 공간을 효율적으로 사용하기 위함이다
- PCB(Process Control Block)
  - 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 의미하며, 프로세스가 생성되면 운영체제는 PCB를 생성한다
  - 프로세스 스케줄링 상태, 프로세스 ID와 권한, 프로그램 카운터, CPU 레지스터와 스케줄링 정보 등
  - CPU가 해당 프로세스를 실행하기 위한 메타 정보들 컨텍스트(context)라고 하며 컨텍스트가 PCB에 저장되어 있다
- 컨텍스트 스위칭(context switching)
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/e69d4bc5-dfc4-4e3e-8324-668d0827a312)
  - 기존에 실행되던 프로세스를 중단하고 다른 프로세스로 교체하는 과정을 의미한다
  - 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생하며 PCB를 교환하는 과정을 의미한다
  - 스레드에서도 스위칭이 일어나며 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 프로세스 스위칭보다 빠르다
- IPC(Inter Process Communication)
  - 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘을 의미한다
  - 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행하는 멀티프로세스는 IPC가 가능하다
  - IPC의 종류로는 공유 메모리, 파일, 소켓, 익명/명명 파이프, 메시지 큐 등이 있다
  - IPC는 메모리가 완전히 공유되는 스레드보다는 속도가 느리다
    - 공유 메모리(shared memory): 여러 프로세스가 접근 권한이 부여된 공유 메모리 블록을 통해 서로 통신하는 방법
    - 익명 파이프(unamed pipe): 프로세스 간에 FIFO 방식으로 데이터를 주고받으며, 단방향의 읽기 전용, 쓰기 전용 파이프를 만들어 통신하는 방법. 부모, 자식 프로세스 간에만 사용할 수 있으며 다른 네트워크 상에서는 사용이 불가하다
    - 명명 파이프(named pipe): 클라이언트/서버 통신을 위한 파이프 서버를 통해 통신하는 방법. 다른 네트워크상의 컴퓨터와도 통신할 수 있다
    - 메시지 큐(message queue): 메시지를 큐 형태로 관리하며, 커널에서 전역적으로 관리하며 사용이 쉽다
- 스레드와 멀티스레딩
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/623a58ad-37a0-45ad-835c-aa586796f747)
  - 스레드는 프로세스의 실행 가능한 가장 작은 단위로 프로세스는 여러개의 스레드를 가질 수 있다
  - 스레드는 코드, 데이터, 힙 영역을 공유하고, 그 영역은 각각 생성된다
  - 멀티스레딩은 프로세스 내 작업을 여러 개의 스레드로 처리하는 방법이며 빠른 속도와 동시성에도 큰 장점이 있지만, 한 스레드가 다른 스레드에 영향을 줄 수 있다는 단점도 있다
    - 동시성: 서로 독립적인 작업들을 작은 단위로 나누고, 동시에 실행되는 것처럼 보여주는 것
- 공유 자원과 임계 구역
  - 공유 자원(shared resource): 시스템 안에서 각 프로세스와 스레드가 함께 접근할 수 있는 자원 또는 변수를 의미한다
  - 경쟁 상태(race condition): 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황을 의미한다
  - 임계 구역(critical section): 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서등의 이유로 결과가 달라지는 코드 영역을 의미한다
    - 임계 구역 해결 조건 3가지
      - 상호 배제(mutual exclusion): 한 프로세스가 임계 구역에 들어갔을 때 다른 프로세스는 들어갈 수 없다
      - 한정 대기(bounded waiting): 특정 프로세스가 영원히 임계 구역에 들어가지 못하면 안 된다. 즉, 틍정 프로세스가 임계구역에 진입하지 못하면 안된다
      - 진행 융통성(progress flexibility): 임계구역에 프로세스가 없다면 어떠한 프로세스라도 들어가서 자원을 활용할 수 있다. 즉, 두 프로세스가 자원을 번갈아 쓴다고 가정할 때 한 쪽에서 자원을 안쓰고 있다고해서 다른 한 쪽 프로세스가 자원을 쓰고싶어도 자신의 turn이 아니라고 기다리는 것은 효율적이지 못하다는 의미
    - 뮤텍스(mutex)
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/3c20ea10-331f-4609-872d-a9549bf945ba)
      - 프로세스나 스레드가 공유 자원을 lock()을 통해 점금 설정하고 사용한 후 unlock()을 통해 잠금 해제하는 객체
      - 0과 1의 두 가지 값만 가질 수 있는 바이너리 세마포어라고도 한다
    - 세마포어(semaphore)
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/5575b035-7db0-417d-8ca9-9564b7f434d4)
      - 일반화된 뮤텍스로 간단한 정수 값과 wait(또는 P) 함수와 signal(또는 V) 함수로 공유 자원에 대한 접근을 처리한다
      - wait()은 자신의 차례가 올 때까지 기다리는 함수이며, signal()은 다음 프로세스로 순서를 넘겨주는 함수이다
      - 세마포어에는 조건 변수가 없고 프로세스나 스레드가 세마포어 값을 수정할 때 다른 프로세스나 스레드가 동시에 세마포어 값을 수정할 수 없다
    - 모니터(monitor)
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/6b491919-4ad8-45c0-89e5-4559416c47b1)
      - 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공한다
      - 임계구역에 접근하고자 하는 프로세스는 직접 P()나 V()를 사용하지 않고 모니터에 작업 요청한다
      - 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에게 알려준다
- 교착 상태(Deadlock)
  - 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 의미한다
  - 교착 상태의 원인
    - 상호 배제(mutual exclusion): 한 프로세스가 자원을 독점하고 있어서 다른 프로세스들의 접근이 불가능 하다
    - 점유 대기(hold and wait): 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태이다
    - 비선점(no preemption): 다른 프로세스의 자원을 강제적으로 가져올 수 없다
    - 환형 대기(circular wait): 자원을 기다리는 프로세스 간의 사이클이 형성되어 있다
  - 교착 상태의 해결 방법
    1. 자원을 할당할 때 교착 상태의 원인인 4가지 조건이 성립되지 않도록 설계한다
    2. 프로세스 당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 은행원 알고리즘을 사용한다
    3. 탐지(detection) 및 복구(recovery): 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다
    4. 무시(ignore): 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생해면 사용자가 작업을 중단한다
    - 은행원 알고리즘(Banker's Algorithm)
      - 프로세스 시작시 자신이 필요한 각 자원의 최대(max) 개수를 미리 선언합니다
      - 각 프로세스에서 자원요청이 있을때 요청을 승인하면 시스템이 안전한 상태(safe state)로 유지되는 경우에만 자원을 할당합니다
      - 불안정 상태(unsafe state)가 예상되면 다른 프로세스가 끝날 때까지 대기를 합니다



### 2. CPU 스케줄링 알고리즘
- CPU 스케줄링 알고리즘에 따라 어떤 프로그램에 CPU 소유권을 줄지 결정하고, 프로세스에서 해야 하는 일을 스레드 단위로 CPU에 할당
- 스케줄링 알고리즘의 목표는 CPU 이용률은 높게, 시간당 최대한 많은 일을 수행하게, 준비 큐(ready queue)에 있는 프로세스는 적게, 응답 시간은 짧게 설정하는 것을 목표로 한다
- ![image](https://github.com/kimho1wq/TIL/assets/15611500/a2df598e-b582-4fc0-b9f1-432e191e3a4f)
  - 비선점형 방식(non-preemptive)
    - 프로세스가 스스로 CPU 소유권을 포기하는 방식으며, 강제로 프로세스를 중지하지 않는다
    - 컨텍스트 스위칭으로 인한 부하가 적은 방식이다
    - FCFS(First Come, First Served)
      - 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘
      - 길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect, 호위 효과)이 발생할 수 있다
    - SJF(Shortest Job First)
      - 실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘
      - 긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation)이 발생할 수 있다
    - 우선순위
      - 기존 SJF에 우선순위를 부여하여 오래된 작업일수록 우선순위를 높이는 aging 방법을 적용한 알고리즘
  - 선점형 방식(preemptive)
    - 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에게 CPU 소유권을 할당하는 방식
    - RR(Round Robin)
      - 우선순위 스케줄링(priority scheduling)의 일종으로 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 보내는 알고리즘
      - 할당 시간이 너무 크면 FCFS 알고리즘되고, 너무 짧으면 컨텍스트 스위칭의 오버헤드가 커진다
      - Q만큼의 할당 시간이 부여되었고 N개의 프로세스가 있다면 (N-1)*Q 시간이 지나면 다시 자기 차례가 된다
      - 일반적으로 전체 작업 시간은 길어지지만 평균 응답 시간이 짧아져서 현대 컴퓨터가 사용하는 알고리즘이다
    - SRF(Shortest Remaining time First)
      - SRF는 SJF 도중 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지시키고 해당 프로세스를 수행하는 알고리즘
      - SJF는 중간에 실행 시간이 더 짧은 작업이 들어와도 기존 짧은 작업을 모두 수행하고 그 다음 작업을 이어나간다
    - 다단계 큐
      - 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 RR이나 FCFS등 다른 스케줄링 알고리즘을 적용하는 알고리즘
      - 큐 간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성은 떨어진다
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/c22898c3-1bd8-4ad7-841f-49569c500ad1)








                                               