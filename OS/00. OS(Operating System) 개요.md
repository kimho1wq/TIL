## OS(Operating System) 이란
- 운영체제(OS, Operating System)는 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스로 한정된 메모리나 시스템의 자원을 효율적으로 분배해준다
- 운영체제 역할
  1. CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리한다
  2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리한다
  3. 디스크 파일 관리: 디스크 파일을 어떤 방법으로 보관할지 관리한다
  4. I/O 디바이스 관리: 마우스, 키보드와 같은 I/O 디바이스간에 데이터를 주고 받는 것을 관리한다
- 운영체제 구조
  - 
    - GUI(Graphical user Interface): 사용자가 편리하게 사용하도록 입출력등의 기능을 그래픽으로 구현
    - 커널: 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템과 I/O관리 등 운영체제의 중추적인 역할을 한다
    - 드라이버: 하드웨어를 제어하기 위한 소프트웨어
  - 시스템콜
    - 
    - 운영체제가 커널에 접근하기 위한 추상화된 인터페이스로, 유저 프로그램이 운영체제의 서비스를 받기 위해 시스템콜을 통해 커널에 접근한다
    - 유저 프로그램의 I/O 디바이스 등과 같은 컴퓨터 자원에 대한 직접 접근을 차단하고 보호할 수 있다
- 컴퓨터의 요소
  - CPU(Central Processing Unit)
    - 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치로, 메모리에 존재하는 명령어를 해석해서 실행한다
      - 제어장치(CU, Control Unit)는 I/O장치의 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정한다
      - 레지스터(Register)는 CPU 안에 있는 임시기억장치로 메모리보다 훨씬 빠르다
      - 산술논리연산장치(ALU, Arithmetic Logic Unit)는 산술 연산(덧셈,뺄셈 등)과 논리 연산(배타적 논리합,논리곱 등)을 계산하는 디지털 회로이다
    - 관리자 역할을 하는 운영체제의 커널이 프로그램을 메모리에 올려 프로세스를 생성하면 이를 CPU가 처리한다
    - 인터럽트(interrupt)
      - 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 의미하며, 인터럽트가 발생되면 이를 처리하기 위한 인터럽트 핸들러 함수가 실행된다
      - I/O 디바이스 등에서 발생하는 하드웨어 인터럽트와 프로세스 오류 등으로 시스템콜을 호출할 때 발생하는 소프트웨어 인터럽트로 나뉜다
  - DMA 컨트롤러
    - I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치를 의미한다
    - 과도한 인터럽트에 대한 CPU 부하를 막아 주며, 하나의 작업을 CPU와 DMA 컨트롤러가 동시에 수행하지 않는다
  - 메모리(memory): 데이터나 명령어 등을 기록하는 기록 장치를 의미하며, 보통 RAM(Random Access Memory)를 메모리라고 부른다
  - 타이머(timer): 특정 프로그램에 시간 제한을 걸기 위해 사용된다
  - 디바스터 컨트롤러(device controller): I/O 디바이스와 연결되어 있는 작은 CPU를 의미하고, 각 디바이스에 대한 데이터를 임시로 저장하기 위한 버퍼도 존재한다

### 1. 메모리
- 메모리 계층
  - 
  - 레지스터: CPU 안에 있는 작은 메모리, 휘발성이 있고, 기억 용량이 가장 적다
  - 캐시(cache)
    - 빠른 장치와 느린 장치에서 속도 차이에 대한 병목 현상을 줄이기 위한 메모리로 휘발성이 있고 CPU(레지스터)와 메모리 사이에 위치한다
    - 시간 지역성(temporal locality, 계속 사용하는 for문의 변수 등)와 공간 지역성(spatial locality, 배열과 같은 연속된 공간 등)를 고려하여 자주 사용하는 데이터를 기반으로 설정해야 한다
    - 캐시 매핑
      - 캐시가 히트되기 위해 캐시에 데이터를 매핑하는 방법을 의미한다
      - 직접 매핑(directed mapping)은 메모리가 1~100, 캐시가 1~10이라면 1:1~10,2:11~20...과 같이 순서를 일치시켜 매핑하여 처리가 빠르지만 충돌이 자주 발생한다
      - 연관 매핑(associative mapping)은 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하여 충돌을 적지만 모든 블록을 탐색해야 해서 속도가 느리다
      - 집합 연관 매핑(set associative mapping)은 직접 매핑과 연관 매핑을 합쳐 놓은 것으로 순서는 일치시키지만 블록으로 나눠 그 안에는 연관 매핑을 한다
    - 웹 브라우저의 캐시
      - 쿠키: 만료기한이 있는 키-값 저장소로 다른 도메인에서 요청했을 때 자동으로 전송된다
      - 세션: 만료기한이 없는 키-값 저장소로 탭 단위로 스토리지를 생성하고 탭을 닫으면 데이터가 삭제된다
      - 로컬 스토리지: 만료기한이 없는 키-값 저장소로 도메인 단위로 저장되고 브라우저를 닫아도 유지된다
    - 데이터베이스의 캐시
      - 
  - 주기억장치: RAM을 가리키고 휘발성이 있다
  - 보조기억장치: HDD, SSH를 가리키고 비휘발성이고, 속도가 느린만큼 용량이 크다
- 가상 메모리(virtual memory)
  - 메모리 관리 기법의 하나로 실제 메모리 자원을 추상화하여 사용자에게 매우 큰 메모리로 보이게 만드는 기법이다
  - 실제 메모리상에 있는 주소를 physical address 라고 하고 최소 크기의 단위는 프레임(frame)을 사용한다
  - 가상 메모리상에 있는 주소를 logical address 라고 하고 최소 크기 단위는 페이지(page)를 사용한다
  - 가상 주소는 메모리관리장치(MMU)에 의해 실제 주소로 변환되며 페이지 테이블(page table)에 가상 주소와 실제 주소가 매핑되어 있다
    - TLB(Translation Lookaside Buffer): 페이지 테이블에 있는 리스트를 보관하며 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
  - 페이지 폴트(page fault)
    - 가상 메모리(프로세스의 주소 공간)에는 존재하지만 실제 메모리에 없는 데이터에 접근할 경우 발생
    - 스와핑(swapping): 페이지 폴트가 발생하여 메모리에서 당장 사용하지 않는 영역을 HDD로 옮기고 HDD의 일부분을 메모리처럼 불러와 사용하는 작업
    - 페이지 폴트 과정 
      1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩(trap)을 발생해서 운영체제에 알린다
      2. 운영체제는 CPU의 동작을 잠시 멈추고, 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인한다
      3. 가상 메모리에도 없다면 프로세스를 중단시키고 현재 물리 메모리에 비어 있는 프레임을 찾는다
      4. 빈 공간이 없다면 스와핑 시킨 후, 스와핑된 프레임에 해당 페이지를 로드하고 페이지 테이블을 최신화한다
      5. 중단되었던 CPU를 다시 시작한다
  - 쓰레싱(thrashing)
    - 메모리에 너무 많은 프로세스가 동시에 올라가서 메모리의 페이지 폴트율이 높아져 발생하는 컴퓨터의 심각한 성능 저하를 의미한다
    - 
      - 쓰레싱이 발생하면 CPU 이용률이 낮아지고 운영체제는 CPU의 가용성을 높이기 위해 더 많은 프로세스를 메모리에 올리는 악순환이 발생한다
    - 해결 방법
      - 작업 세트(working set): 프로세스의 과거 사용 이력인 지역성(locality)을 통해 페이지 집합을 만들어서 미리 메모리에 로드한다. 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있다
      - PFF(Page Fault Frequency): 페이지 폴트 빈도의 상한선과 하한선을 만들어서 만약 상한선에 도달한다면 메모리 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다
- 메모리 할당
  - 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당한다
  - 메모리 공간에 연속적으로 할당할 수도 있고, 불연속적으로 할당할 수도 있으며, 현대 운영체제는 불연속 할당인 페이징 기법을 주로 사용한다
  - 용어 정리
    - 홀(hole): 할당할 수 잇는 비어 있는 메모리 공간을 의미한다
    - 내부 단편화(internal fragmentation): 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상
    - 외부 단편화(external fragmentation): 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상 (100를 55,45로 나눴을 때 70의 프로그램을 들어가지 못한다)
    - 고정 분할 방식(fixed partition allocation)은 메모리를 미리 나누어 관리하는 방식이며 유연하지 않고 내부 단편화가 발생할 수 있다
    - 가변 분할 방식(variable partition allocation)은 매 시점 프로그램의 크기에 맞게 동적으로 할당하며, 내부 단편화는 없지만 외부 단편화는 존재한다
      - 최초 적합(first fit): 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당한다
      - 최적 적합(best fit): 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다
      - 최악 적합(worst fit): 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당한다
  - 할당 방법
    - 페이징(pageing)
      - 메모리를 동일한 크기의 페이지(보통 4KB)로 나누고 프로그램마다 페이지 테이블(page table)을 두어 메모리에 프로그램을 할당하는 방법
      - 홀의 크기가 균일하지 않은 문제는 없지만 주소 변환이 복잡하다
    - 세그멘테이션(segmentation)
      - 코드 영역, 데이터 영억, 스택 영역, 힙 영역 등의 의미가 있는 단위인 세그먼트(segment)로 메모리를 나누는 방법
      - 공유와 보안 측면에서는 장점을 가지지만 홀 크기가 균일하지 않은 단점이 있다
    - 페이지드 세그멘테이션(paged segmentation): 프로그램을 의미 단위인 세그먼트로 나눈 후 임의의 길이가 아닌 돌일한 크기의 페이지 단위로 나누는 방법
- 페이지 교체 알고리즘
  - 메모리가 한정되어 있기 때문에 스와핑이 발생할 경우 교체해야 하는 부분을 정하는 알고리즘
  - FIFO(First In First Out): 메모리에 가장 먼저 온 페이지를 먼저 교체하는 방법
  - LRU(Least Recently Used)
    - 참조가 가장 오래된 페이지를 바꾸는 방법이며 오래된 것을 파악하기 위해 페이지마다 계수기와 스택이 존재한다
    - 해시 테이블과 이중 연결 리스트로 구현한다
  - NUR(Not Used Recently): clock 알고리즘이라고 하며 최근 참조된 것은 1로 표시하고 아닌것은 0으로 표시한 후 시계 방향으로 돌면서 0을 찾아 교체하는 방법
  - LFU(Least Frequently Used): 가장 참조 횟수가 적은 페이지를 교체하는 방법
























                                               