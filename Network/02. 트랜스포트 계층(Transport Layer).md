## 트랜스포트 계층(Transport Layer)

### 1. 트랜스포트 계층 서비스 및 개요
- 트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 프로세스들(processes) 사이의 논리적 통신(logical communication)을 제공한다
  - 네트워크 계층 프로토콜은 호스트들(hosts) 사이의 논리적 통신(logical communication)을 제공한다
  - 호스트(또는 종단 시스템)은 집과 집사이의 통신이고 프로세스는 그 집 안에서 가족들에게 전달해주는 통신을 의미한다
- TCP(Transmission Control Protocol): 신뢰적이고 연결지향형 서비스를 제공하는 프로토콜
- UDP(User Datagram Protocol): 비신뢰적이고 비연결형인 서비스를 제공하는 프로토콜, 종종 패킷을 데이터그램으로 표현한다

### 2. 다중화와 역다중화
- 다중화(multiplexing): 출발지 호스트에서 프로세스 소켓으로부터 데이터를 모으고, 이에 대한 세그먼트를 생성하기 위해서 각 데이터를 헤더 정보로 캡슐화 하여 네트워크 계층으로 전달하는 작업
- 역다중화(demultiplexing): 도착지 호스트에서 전달받은 세그먼트의 데이터를 올바른 프로세스 소켓으로 전달하는 작업
- 소켓은 유일한 식별자를 가지며, 각 세그먼트는 적절한 소켓을 가리키는 출발지/목적지 포트 번호 필드(port number field)가 존재한다
  - 각 포트번호는 16비트(0~65535) 정수이며 0~1023은 well-known port로 사용을 제한한다(HTTP:80, FTP:21 등 RFC 1700에 명시되어있음)
  - UDP는 목적지 IP 주소와 목적지 포트 번호의 2개의 요소로 식별이 되고, TCP는 출발지 IP 주소와 출발지 포트 번호를 포함해 4개의 요소르 식별이된다

### 3. UDP(User Datagram Protocol)
- UDP 개요
  - 다중화/역다중화 기낭과 간단한 오류 검사 기능을 추가한, 트랜스포트 계층 프로토콜이 할 수 있는 최소기능으로 동작한다
  - 데이터 손실을 허용하고 최소 전송률을 요구하는 실시간 애플리케이션에서 주로 사용된다
  - 연결 설정이 없고(connectionless), 연결 상태를 유지하지 않는다(stateless)
    - 연결 상태는 수/송신 버퍼, 혼잡제어 파라미터, 순서/확인 번호 파라미터를 포함한다
    - 이는 TCP의 신뢰적인 데이터 전송과 혼잡 제어를 제공하기 위해 필요하다
  - UDP의 오베헤드는 8바이트, TCP의 오버헤드는 20바이트로, 패킷의 헤더 사이즈가 작다
  - NFS(원격 파일 서버), DNS(도메인 네임 시스템), SNMP(네트워크 관리) 등의 애플리케이션에서 일반적으로 UDP를 사용한다
  - 애플리케이션 자체에서 신뢰성을 제공한다면, 신뢰적인 데이터 전송을 할 수 있다
- UDP 세그먼트 구조
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/dce44af1-0e2f-4926-85f3-87fd499741cb)
  - UDP 헤더는 2바이트씩 구성된 4개의 필드를 가지고, 체크섬(checksum)은 세그먼트에 오류가 발생했는지를 검사하기 위해 존재한다
    - 수신자에서 4개의 필드 모든 16비트를 더하면 1111...1111이 되도록 체크섬을 만들어 오류를 검출한다
    - 종단간의 원리(end-end principle)에 따라 하위 레벨에서 오류 검사를 제공하지 않는 프로토콜을 사용할 수 있기 때문에 UDP에서도 체크섬을 제공한다
- 신뢰성이 있는 데이터 전송의 원리
  - 신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않으며, 모든 데이터는 전송된 순서대로 전달된다
  - 신뢰적인 데이터 전송(reliable data transfer) 프로토콜의 구축 (단, 전송된 패킷은 송신된 순서대로 수신된다고 가정)
    - rdt1.0, no bit error, no loss of packets (완벽한 신뢰적인 채널)
      - ![image](https://github.com/kimho1wq/TIL/assets/15611500/c2173589-2be6-429f-b9f6-f46e61dc5dd9)
    - rdt2.0, with bit error, no loss of packets (비트 오류가 있는 채널)
      - ARQ(Automatic Repeat reQuest, 자동 재전송 요구) 프로토콜을 사용한다
      - 추후 정리 필요
    - rdt3.0, with bit error, with loss of packets
      - 추후 정리 필요

  
### 4. TCP(Transmission Control Protocol)
- TCP 개요
  - 데이터 스트림이 손상되지 않으면서, 손실이나 중복이 없고, 순서가 유지된다는 것을 보장한다
  - 두 프로세스가 서로 통신하기 위해선 핸드셰이크로 연결해야 하는 연결지향형(connection-oriented) 프로토콜이다
  - 오직 종단 시스템에서만 동작하고 중간의 네트워크 요소(라우터 또는 브리지) 에서는 동작하지 않는다
  - 전이중(full-duplex) 서비스를 제공하고, 단일 송신 동작으로 여러 수신자에게 데이터를 전송하는 멀티캐스팅은 불가능하다 (TCP는 송신자와 수신자가 1:1)
  - 세그먼트의 크기는 최대 세그먼트 크기(MMS, maximum segment size)로 제한된다
  - MSS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 계층 프레임의 길이인 최대 전송 단위(MTU, maximum transmission unit)에 의해 결정된다
- TCP 세그먼트 구조
  - ![image](https://github.com/kimho1wq/TIL/assets/15611500/38272ae6-30c8-4ca4-a219-d72b5e265d13)
  - TCP 헤더는 일반적으로 20바이트이며, TCP 옵션(option) 필드 때문에 가변적인 길이가 될 수 있어서 헤더 길이(header length) 필드에 길이를 표시한다
  - 신뢰적인 데이터 전송 서비스 구현을 위해 순서 번호(sequence number) 필드와 확인응답 번호(acknowledgement number) 필드가 존재한다
  - 순서 번호(seq)는 전송된 바이트 스트림의 첫 번째 바이트의 번호이다
  - 확인응답 번호(ack)는 송신자가 수신자로 부터 기대하는 다음 바이트의 순서 번호이다
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/0b46e743-70f0-4a1f-9fba-8c264f0ca462)
    1. 호스트 A가 B로부터 0~535의 바이트를 포함하는 세그먼트와 900~1000 바이트를 포함하는 다른 세그먼트를 받았다면
    2. 호스트 A는 확인응답 번호 필드에 536을 삽입하고 그것을 B에 송신한다
    3. 수신자는 순사가 틀린 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해서 기다린다
  - 수신 윈도우(receive window) 필드는 흐름제어(flow control)에 사용된다
- TCP 연결 관리
  - 연결 시작: 3-way handshake
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/4e6cce41-9ff8-494d-a37f-a5fa82c2c785)
    1. 클라이언트는 헤더에 SYN flag=1 비트와 최초의 순서번호(client_isn)를 포함한 SYN 세그먼트를 서버에 송신한다
    2. 서버는 TCP 버퍼와 변수들을 할당하고 클라이언트에게 SYN flag=1 비트와 순서번호와 확인응답 번호를 포함한 연결 승인 SYNACK 세그먼트를 송신한다
    3. 클라이언트는 SYNACK 세그먼트를 수신하면 TCP 버퍼와 변수들을 할당하고 SYN flag=0 비트와 확인응답 번호를 이용해 연결을 확인한다.
  - 연결 종료: 4-way handshake
    - ![image](https://github.com/kimho1wq/TIL/assets/15611500/201f5e3b-9d14-4e11-880a-4f0751c50a87)
    1. 클라이언트는 FIN flag=1 비트의 종료 세그먼트를 송신한다
    2. 서버는 세그먼트 수신을 확인하고 ACK 세그먼트를 보낸다
    3. 서버는 FIN flag=1 비트의 종료 세그먼트를 송신한다
    4. 클라이언트는 세그먼트 수신을 확인하고 ACK 세그먼트를 보낸다. 이 시점에서 잠시 대기 후에, 두 호스트의 모든 자원들은 할당이 해제된다
- 흐름제어(flow-control)
  - TCP는 송신자가 수신자의 버퍼를 오버플로 시키는 것을 방지하기 위해서 애플리케이션에게 흐름제어 서비스를 제공한다
  - 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다
  - 송신자는 수신 측에서 가용한 버퍼 공간이 얼마나 되는지를 송신자에게 알려주는 수신 윈도우(receive window)라는 변수를 유지하여 흐름제어를 제공한다
- 혼잡제어(congestion control)
  - IP 계층이 네트워크 혼잡에 관해서 피드백이 제공되지 않으므로, TCP는 종단간의 혼잡제어를 사용하여 네트워크 혼잡을 일으키는 송신자를 억제한다
  - TCP 송신자는 자신과 목적지 사이 경로의 혼잡을 감지하고 그에 따라 전송 트래픽 전송률을 제어한다
  - TCP는 혼잡 윈도우(congestion window)를 기록하여 송신자가 네트워크로 트래픽을 전송할 수 있는 비율을 제한하도록 한다
  - TCP 혼잡제어 알고리즘
    - 슬로 스타트(slow start)
    - 혼잡 회피(contestion avoidance)
    - 빠른 회복(fast recovery)



