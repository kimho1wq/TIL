## 컴파일러와 인터프리터의 차이점
- 컴파일러(Compiler)
  - 특정 프로그래밍 언어로 쓰여 있는 문서를, 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말한다.
  - high-level 프로그래밍 언어(ex: C언어)를 low-level 언어(ex: 어셈블리어)로 바꾸어 실행 프로그램을 만들기 위해 사용된다.
- 인터프리터(Interpreter)
  - 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다.
  - high-level 프로그래밍 언어로 작성된 명령어들을 한 번에 한 줄씩 읽어 들여서 중간 형태로 번역하여 그것을 실행한다.
- 인터프리터의 실행은 컴파일된 프로그램보다 실행이 느리고, 매번 실행할 때마다 새로 번역해야 한다.
- 단, 컴파일 시간을 단축할 수 있고, 컴파일러는 하드웨어에 종속적이지만 인터프리터는 종속적이지 않게 실행 가능하고, 오류가 발생하면 이후 코드는 실행하지 않기 때문에 보안 관점에서 유리할 수도 있다.

## 프로그래밍 패러다임
- 프로그래밍 패러다임(programming paradigm)은 프로그래밍의 관점을 갖게 해주는 개발 방법론으로 선언형 명령형 등으로 나뉜다
  - 선언형: 무엇을 풀어내는가에 집중하는 패러다임으로, 함수형 프로그래밍이 대표적이다
  - 명령형: 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 패러다임으로, 객체지향형과 절차지향형이 있다

## 객체지향 설계 원칙(SOLID)
- 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 모든 클래스는 각각 하나의 책임만 가져야 한다
  - A라는 로직이 존재한다면 어떠한 클래스는 A에 관한 클래스여야 한다
- 개방-폐쇄 원칙(OCP, Open Closed Principle)
  - 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀 있어야 한다
  기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 한다
- 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
  - 계층 관계가 있는 객체의 경우 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게 만들어야 한다
- 인터페이스 분리 원칙(Interface Segregation Principle)
  - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 한다
- 의존 역전 원칙(DIP, Dependency Inversion Principle)
  - 잘 변하지 않는 추상화된 인터페이스나 상위 클래스에 의존을 두어 변하기 쉬운 것의 영향을 받지 않게 한다
  - 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해 있어야 한다














